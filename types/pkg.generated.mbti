// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/wasmoon/types"

// Values
pub fn compute_canonical_type_indices(Array[SubType], type_rec_groups? : Array[Int]) -> Array[Int]

pub fn extract_func_types(Array[SubType]) -> Array[FuncType]

pub fn func_types_equal(FuncType, FuncType) -> Bool

pub fn func_types_to_subtypes(Array[FuncType]) -> Array[SubType]

pub fn get_rec_group_info(Array[Int], Int) -> (Int, Int)

// Errors

// Types and methods
pub(all) struct ArrayType {
  element : FieldType
}
pub impl Eq for ArrayType
pub impl Show for ArrayType

pub(all) enum BlockType {
  Empty
  Value(ValueType)
  MultiValue(Array[ValueType])
  InlineType(Array[ValueType], Array[ValueType])
  TypeIndex(Int)
}
pub impl Eq for BlockType
pub impl Show for BlockType

pub(all) enum CatchHandler {
  Catch(Int, Int)
  CatchRef(Int, Int)
  CatchAll(Int)
  CatchAllRef(Int)
}
pub impl Eq for CatchHandler
pub impl Show for CatchHandler

pub(all) enum CompositeType {
  Func(FuncType)
  Struct(StructType)
  Array(ArrayType)
}
pub impl Eq for CompositeType
pub impl Show for CompositeType

pub(all) struct Data {
  memory_idx : Int
  offset : Array[Instruction]
  init : Bytes
}
pub impl Eq for Data
pub impl Show for Data

pub(all) enum ElemMode {
  Active(Int, Array[Instruction])
  Passive
  Declarative
}
pub impl Eq for ElemMode
pub impl Show for ElemMode

pub(all) struct Element {
  mode : ElemMode
  type_ : ValueType
  init : Array[Array[Instruction]]
}
pub impl Eq for Element
pub impl Show for Element

pub(all) struct Export {
  name : String
  desc : ExportDesc
}
pub impl Eq for Export
pub impl Show for Export

pub(all) enum ExportDesc {
  Func(Int)
  Table(Int)
  Memory(Int)
  Global(Int)
  Tag(Int)
}
pub impl Eq for ExportDesc
pub impl Show for ExportDesc

pub(all) struct FieldType {
  storage_type : StorageType
  mutable : Bool
}
pub impl Eq for FieldType
pub impl Show for FieldType

pub(all) struct FuncType {
  params : Array[ValueType]
  results : Array[ValueType]
}
pub fn FuncType::structural_hash(Self) -> Int
pub fn FuncType::structurally_equal(Self, Self, Int, Int) -> Bool
pub impl Eq for FuncType
pub impl Show for FuncType

pub(all) struct FunctionCode {
  locals : Array[ValueType]
  body : Array[Instruction]
}
pub impl Eq for FunctionCode
pub impl Show for FunctionCode

pub(all) struct Global {
  type_ : GlobalType
  init : Array[Instruction]
}
pub impl Eq for Global
pub impl Show for Global

pub(all) struct GlobalType {
  value_type : ValueType
  mutable : Bool
}
pub impl Eq for GlobalType
pub impl Show for GlobalType

pub(all) struct Import {
  mod_name : String
  name : String
  desc : ImportDesc
}
pub impl Eq for Import
pub impl Show for Import

pub(all) enum ImportDesc {
  Func(Int)
  Table(TableType)
  Memory(MemoryType)
  Global(GlobalType)
  Tag(Int)
}
pub impl Eq for ImportDesc
pub impl Show for ImportDesc

pub(all) enum Instruction {
  Unreachable
  Nop
  Block(BlockType, Array[Instruction])
  Loop(BlockType, Array[Instruction])
  If(BlockType, Array[Instruction], Array[Instruction])
  Br(Int)
  BrIf(Int)
  BrTable(Array[Int], Int)
  Return
  Call(Int)
  CallIndirect(Int, Int)
  CallRef(Int)
  ReturnCall(Int)
  ReturnCallIndirect(Int, Int)
  ReturnCallRef(Int)
  Throw(Int)
  ThrowRef
  TryTable(BlockType, Array[CatchHandler], Array[Instruction])
  Drop
  Select
  SelectTyped(Array[ValueType])
  LocalGet(Int)
  LocalSet(Int)
  LocalTee(Int)
  GlobalGet(Int)
  GlobalSet(Int)
  TableGet(Int)
  TableSet(Int)
  TableSize(Int)
  TableGrow(Int)
  TableFill(Int)
  TableCopy(Int, Int)
  TableInit(Int, Int)
  I32Load(Int, Int, Int64)
  I64Load(Int, Int, Int64)
  F32Load(Int, Int, Int64)
  F64Load(Int, Int, Int64)
  I32Load8S(Int, Int, Int64)
  I32Load8U(Int, Int, Int64)
  I32Load16S(Int, Int, Int64)
  I32Load16U(Int, Int, Int64)
  I64Load8S(Int, Int, Int64)
  I64Load8U(Int, Int, Int64)
  I64Load16S(Int, Int, Int64)
  I64Load16U(Int, Int, Int64)
  I64Load32S(Int, Int, Int64)
  I64Load32U(Int, Int, Int64)
  I32Store(Int, Int, Int64)
  I64Store(Int, Int, Int64)
  F32Store(Int, Int, Int64)
  F64Store(Int, Int, Int64)
  I32Store8(Int, Int, Int64)
  I32Store16(Int, Int, Int64)
  I64Store8(Int, Int, Int64)
  I64Store16(Int, Int, Int64)
  I64Store32(Int, Int, Int64)
  MemorySize(Int)
  MemoryGrow(Int)
  MemoryInit(Int, Int)
  DataDrop(Int)
  MemoryCopy(Int, Int)
  MemoryFill(Int)
  ElemDrop(Int)
  RefNull(ValueType)
  RefIsNull
  RefFunc(Int)
  RefAsNonNull
  RefEqInstr
  BrOnNull(Int)
  BrOnNonNull(Int)
  I32Const(Int)
  I64Const(Int64)
  F32Const(Float)
  F64Const(Double)
  I32Eqz
  I32Eq
  I32Ne
  I32LtS
  I32LtU
  I32GtS
  I32GtU
  I32LeS
  I32LeU
  I32GeS
  I32GeU
  I32Clz
  I32Ctz
  I32Popcnt
  I32Add
  I32Sub
  I32Mul
  I32DivS
  I32DivU
  I32RemS
  I32RemU
  I32And
  I32Or
  I32Xor
  I32Shl
  I32ShrS
  I32ShrU
  I32Rotl
  I32Rotr
  I32Extend8S
  I32Extend16S
  I64Eqz
  I64Eq
  I64Ne
  I64LtS
  I64LtU
  I64GtS
  I64GtU
  I64LeS
  I64LeU
  I64GeS
  I64GeU
  I64Clz
  I64Ctz
  I64Popcnt
  I64Add
  I64Sub
  I64Mul
  I64DivS
  I64DivU
  I64RemS
  I64RemU
  I64And
  I64Or
  I64Xor
  I64Shl
  I64ShrS
  I64ShrU
  I64Rotl
  I64Rotr
  I64Extend8S
  I64Extend16S
  I64Extend32S
  F32Eq
  F32Ne
  F32Lt
  F32Gt
  F32Le
  F32Ge
  F32Abs
  F32Neg
  F32Ceil
  F32Floor
  F32Trunc
  F32Nearest
  F32Sqrt
  F32Add
  F32Sub
  F32Mul
  F32Div
  F32Min
  F32Max
  F32Copysign
  F64Eq
  F64Ne
  F64Lt
  F64Gt
  F64Le
  F64Ge
  F64Abs
  F64Neg
  F64Ceil
  F64Floor
  F64Trunc
  F64Nearest
  F64Sqrt
  F64Add
  F64Sub
  F64Mul
  F64Div
  F64Min
  F64Max
  F64Copysign
  I32WrapI64
  I32TruncF32S
  I32TruncF32U
  I32TruncF64S
  I32TruncF64U
  I64ExtendI32S
  I64ExtendI32U
  I64TruncF32S
  I64TruncF32U
  I64TruncF64S
  I64TruncF64U
  F32ConvertI32S
  F32ConvertI32U
  F32ConvertI64S
  F32ConvertI64U
  F32DemoteF64
  F64ConvertI32S
  F64ConvertI32U
  F64ConvertI64S
  F64ConvertI64U
  F64PromoteF32
  I32ReinterpretF32
  I64ReinterpretF64
  F32ReinterpretI32
  F64ReinterpretI64
  I32TruncSatF32S
  I32TruncSatF32U
  I32TruncSatF64S
  I32TruncSatF64U
  I64TruncSatF32S
  I64TruncSatF32U
  I64TruncSatF64S
  I64TruncSatF64U
  StructNew(Int)
  StructNewDefault(Int)
  StructGet(Int, Int)
  StructGetS(Int, Int)
  StructGetU(Int, Int)
  StructSet(Int, Int)
  ArrayNew(Int)
  ArrayNewDefault(Int)
  ArrayNewFixed(Int, Int)
  ArrayNewData(Int, Int)
  ArrayNewElem(Int, Int)
  ArrayGet(Int)
  ArrayGetS(Int)
  ArrayGetU(Int)
  ArraySet(Int)
  ArrayLen
  ArrayFill(Int)
  ArrayCopy(Int, Int)
  ArrayInitData(Int, Int)
  ArrayInitElem(Int, Int)
  RefTest(ValueType)
  RefTestNull(ValueType)
  RefCast(ValueType)
  RefCastNull(ValueType)
  BrOnCast(Int, ValueType, ValueType)
  BrOnCastFail(Int, ValueType, ValueType)
  RefI31
  I31GetS
  I31GetU
  AnyConvertExtern
  ExternConvertAny
}
pub impl Eq for Instruction
pub impl Show for Instruction

pub(all) struct Limits {
  min : Int64
  max : Int64?
}
pub impl Eq for Limits
pub impl Show for Limits

pub(all) struct MemoryType {
  limits : Limits
  is_memory64 : Bool
}
pub fn MemoryType::addr_type(Self) -> ValueType
pub impl Eq for MemoryType
pub impl Show for MemoryType

pub(all) struct Module {
  types : Array[SubType]
  type_rec_groups : Array[Int]
  imports : Array[Import]
  funcs : Array[Int]
  tables : Array[Table]
  memories : Array[MemoryType]
  globals : Array[Global]
  exports : Array[Export]
  mut start : Int?
  elems : Array[Element]
  codes : Array[FunctionCode]
  datas : Array[Data]
  tags : Array[TagType]
}
pub fn Module::empty() -> Self
pub fn Module::get_array_type(Self, Int) -> ArrayType
pub fn Module::get_func_type(Self, Int) -> FuncType
pub fn Module::get_struct_type(Self, Int) -> StructType
pub fn Module::is_array_type(Self, Int) -> Bool
pub fn Module::is_func_type(Self, Int) -> Bool
pub fn Module::is_struct_type(Self, Int) -> Bool
pub fn Module::new() -> Self
pub fn Module::simple(Array[ValueType], Array[ValueType], Array[Instruction], String) -> Self
pub impl Show for Module

pub(all) enum PackedType {
  I8
  I16
}
pub impl Eq for PackedType
pub impl Show for PackedType

pub(all) enum StorageType {
  Val(ValueType)
  Packed(PackedType)
}
pub impl Eq for StorageType
pub impl Show for StorageType

pub(all) struct StructType {
  fields : Array[FieldType]
}
pub impl Eq for StructType
pub impl Show for StructType

pub(all) struct SubType {
  final_ : Bool
  supertypes : Array[Int]
  composite : CompositeType
}
pub fn SubType::from_func(FuncType) -> Self
pub fn SubType::func(Array[ValueType], Array[ValueType]) -> Self
pub fn SubType::simple(CompositeType) -> Self
pub impl Eq for SubType
pub impl Show for SubType

pub struct SubtypingContext {
  types1 : Array[SubType]
  types2 : Array[SubType]
  rec_groups1 : Array[Int]
  rec_groups2 : Array[Int]
  canonical1 : Array[Int]
  canonical2 : Array[Int]
  cross_module : Bool
  visited : Map[(Int, Int), Bool]
}
pub fn SubtypingContext::cross_module(Array[SubType], Array[SubType], rec_groups1? : Array[Int], rec_groups2? : Array[Int], canonical1? : Array[Int], canonical2? : Array[Int]) -> Self
pub fn SubtypingContext::is_subtype(Self, Int, Int) -> Bool
pub fn SubtypingContext::same_module(Array[SubType], rec_groups? : Array[Int], canonical? : Array[Int]) -> Self
pub fn SubtypingContext::validate_declared_subtype(Self, Int, Int) -> Bool
pub fn SubtypingContext::value_type_subtype(Self, ValueType, ValueType, _idx1? : Int, _idx2? : Int) -> Bool

pub(all) struct Table {
  type_ : TableType
  init : Array[Instruction]?
}
pub impl Eq for Table
pub impl Show for Table

pub(all) struct TableType {
  elem_type : ValueType
  limits : Limits
  is_table64 : Bool
}
pub impl Eq for TableType
pub impl Show for TableType

pub(all) struct TagType {
  type_idx : Int
}
pub impl Eq for TagType
pub impl Show for TagType

pub struct TypeEquivalenceContext {
  types1 : Array[SubType]
  types2 : Array[SubType]
  rec_groups1 : Array[Int]
  rec_groups2 : Array[Int]
  cross_module : Bool
  visited : Map[(Int, Int), Bool]
}
pub fn TypeEquivalenceContext::cross_module(Array[SubType], Array[SubType], rec_groups1? : Array[Int], rec_groups2? : Array[Int]) -> Self
pub fn TypeEquivalenceContext::same_module(Array[SubType], type_rec_groups? : Array[Int]) -> Self
pub fn TypeEquivalenceContext::types_equivalent(Self, Int, Int) -> Bool

pub(all) enum Value {
  I32(Int)
  I64(Int64)
  F32(Float)
  F64(Double)
  FuncRef(Int)
  ExternRef(Int)
  ExnRef(Int)
  StructRef(Int)
  ArrayRef(Int)
  I31(Int)
  Null
}
pub impl Eq for Value
pub impl Show for Value

pub(all) enum ValueType {
  I32
  I64
  F32
  F64
  V128
  FuncRef
  ExternRef
  RefFunc
  RefExtern
  RefFuncTyped(Int)
  RefNullFuncTyped(Int)
  AnyRef
  ExnRef
  RefStruct(Int)
  RefNullStruct(Int)
  RefArray(Int)
  RefNullArray(Int)
  RefAny
  RefEq
  RefNullEq
  RefI31
  RefNullI31
  RefNone
  NullRef
  NullFuncRef
  NullExnRef
  NullExternRef
}
pub fn ValueType::is_nullable(Self) -> Bool
pub impl Eq for ValueType
pub impl Show for ValueType

// Type aliases

// Traits
pub trait FromInt64 {
  from_int64_bits(Int64) -> Self
}
pub impl FromInt64 for Int
pub impl FromInt64 for Int64
pub impl FromInt64 for Float
pub impl FromInt64 for Double

pub trait ToInt64 {
  to_int64_bits(Self) -> Int64
}
pub impl ToInt64 for Int
pub impl ToInt64 for Int64
pub impl ToInt64 for Float
pub impl ToInt64 for Double

