// Code Emission
// Generates machine code from VCode representation
//
// This module provides:
// 1. Machine code buffer for accumulating bytes
// 2. AArch64 instruction encoding
// 3. VCode to machine code translation

// ============ Machine Code Buffer ============

///|
/// A buffer for accumulating machine code bytes
pub(all) struct MachineCode {
  bytes : Array[Int] // Using Int for bytes (0-255)
  mut pos : Int
  // Labels for branch targets
  labels : Map[Int, Int] // block_id -> offset
  // Pending fixups for forward branches
  fixups : Array[Fixup]
}

///|
/// A fixup for a forward branch
pub(all) struct Fixup {
  // Offset in the code buffer where the fixup is needed
  offset : Int
  // Target block id
  target_block : Int
  // Kind of fixup
  kind : FixupKind
}

///|
/// Kind of fixup
pub enum FixupKind {
  Branch26 // 26-bit PC-relative branch (B, BL)
  Branch19 // 19-bit PC-relative branch (B.cond, CBZ, CBNZ)
}

///|
pub fn MachineCode::new() -> MachineCode {
  { bytes: [], pos: 0, labels: {}, fixups: [] }
}

///|
/// Emit a single byte
pub fn MachineCode::emit_byte(self : MachineCode, b : Int) -> Unit {
  self.bytes.push(b & 255)
  self.pos = self.pos + 1
}

///|
/// Emit 4 bytes (instruction) as 4 separate bytes
pub fn MachineCode::emit_inst(
  self : MachineCode,
  b0 : Int,
  b1 : Int,
  b2 : Int,
  b3 : Int,
) -> Unit {
  self.emit_byte(b0)
  self.emit_byte(b1)
  self.emit_byte(b2)
  self.emit_byte(b3)
}

///|
/// Current position in the buffer
pub fn MachineCode::current_pos(self : MachineCode) -> Int {
  self.pos
}

///|
/// Define a label at the current position
pub fn MachineCode::define_label(self : MachineCode, block_id : Int) -> Unit {
  self.labels.set(block_id, self.pos)
}

///|
/// Add a fixup for a forward branch
pub fn MachineCode::add_fixup(
  self : MachineCode,
  target_block : Int,
  kind : FixupKind,
) -> Unit {
  // Fixup is at current position - 4 (since we already emitted the instruction)
  self.fixups.push({ offset: self.pos - 4, target_block, kind })
}

///|
/// Resolve all pending fixups
pub fn MachineCode::resolve_fixups(self : MachineCode) -> Unit {
  for fixup in self.fixups {
    match self.labels.get(fixup.target_block) {
      Some(target_offset) => {
        let pc_offset = (target_offset - fixup.offset) / 4 // Instructions are 4 bytes
        match fixup.kind {
          Branch26 => {
            // Patch bits [25:0] with the 26-bit offset
            // Keep opcode bits in byte 3
            let imm26 = pc_offset & 0x3FFFFFF
            self.bytes[fixup.offset] = imm26 & 255
            self.bytes[fixup.offset + 1] = (imm26 >> 8) & 255
            self.bytes[fixup.offset + 2] = (imm26 >> 16) & 255
            // Keep upper bits of byte 3 (opcode)
            let old_b3 = self.bytes[fixup.offset + 3]
            self.bytes[fixup.offset + 3] = (old_b3 & 252) | ((imm26 >> 24) & 3)
          }
          Branch19 => {
            // Patch bits [23:5] with the 19-bit offset
            let imm19 = pc_offset & 0x7FFFF
            // imm19 goes into bits [23:5], so bytes 0-2 primarily
            // Byte 0: bits [7:5] from imm19 bits [2:0], keep bits [4:0] (Rt)
            let old_b0 = self.bytes[fixup.offset]
            self.bytes[fixup.offset] = (old_b0 & 31) | ((imm19 << 5) & 224)
            self.bytes[fixup.offset + 1] = (imm19 >> 3) & 255
            self.bytes[fixup.offset + 2] = (imm19 >> 11) & 255
            // Byte 3: keep opcode, add top bits of imm19
            let old_b3 = self.bytes[fixup.offset + 3]
            self.bytes[fixup.offset + 3] = (old_b3 & 255) | 0
          }
        }
      } // imm19 high bits already covered
      None => () // Label not found, skip (should not happen in valid code)
    }
  }
}

///|
/// Get the generated bytes
pub fn MachineCode::get_bytes(self : MachineCode) -> Array[Int] {
  self.bytes
}

///|
/// Get size in bytes
pub fn MachineCode::size(self : MachineCode) -> Int {
  self.pos
}

// ============ AArch64 Instruction Encoding ============

// Helper to build instruction from fields

///|
fn build_inst(
  b3 : Int,
  b2 : Int,
  b1 : Int,
  b0 : Int,
  rd : Int,
  rn : Int,
  rm : Int,
) -> (Int, Int, Int, Int) {
  // Most AArch64 instructions have:
  // - Rd in bits [4:0]
  // - Rn in bits [9:5]
  // - Rm in bits [20:16] (for register operations)
  let byte0 = b0 | (rd & 31) | ((rn & 7) << 5)
  let byte1 = b1 | ((rn >> 3) & 3) | ((rm & 15) << 4)
  let byte2 = b2 | ((rm >> 4) & 1)
  let byte3 = b3
  (byte0, byte1, byte2, byte3)
}

// Register encoding helper

///|
fn reg_num(reg : Reg) -> Int {
  match reg {
    Physical(preg) => preg.index
    Virtual(_) => abort("Virtual register in code emission")
  }
}

// Writable register encoding helper

///|
fn wreg_num(wreg : Writable) -> Int {
  reg_num(wreg.reg)
}

///|
/// Encode ADD (shifted register): ADD Xd, Xn, Xm
/// Opcode: 0x8B000000 = 10001011 00000000 00000000 00000000
pub fn emit_add_reg(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  // sf=1 | 00 | 01011 | shift=00 | 0 | Rm[4:0] | imm6=0 | Rn[4:0] | Rd[4:0]
  // Byte 3: 0x8B = 139
  // Byte 2: 0 | Rm[4] | 0000 | Rm[3:0] >> 4
  // Byte 1: Rm[3:0] << 4 | 0 | Rn[4:2]
  // Byte 0: Rn[1:0] << 5 | Rd[4:0]
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((rm & 15) << 4)
  let b2 = (rm >> 4) & 1
  let b3 = 139 // 0x8B
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode ADD (immediate): ADD Xd, Xn, #imm12
/// Opcode: 0x91000000
pub fn emit_add_imm(mc : MachineCode, rd : Int, rn : Int, imm12 : Int) -> Unit {
  // sf=1 | 00 | 100010 | sh=0 | imm12[11:0] | Rn[4:0] | Rd[4:0]
  let imm = imm12 & 0xFFF
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((imm & 31) << 3)
  let b2 = (imm >> 5) & 127
  let b3 = 145 // 0x91
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode SUB (shifted register): SUB Xd, Xn, Xm
/// Opcode: 0xCB000000
pub fn emit_sub_reg(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((rm & 15) << 4)
  let b2 = (rm >> 4) & 1
  let b3 = 203 // 0xCB
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode SUB (immediate): SUB Xd, Xn, #imm12
/// Opcode: 0xD1000000
pub fn emit_sub_imm(mc : MachineCode, rd : Int, rn : Int, imm12 : Int) -> Unit {
  let imm = imm12 & 0xFFF
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((imm & 31) << 3)
  let b2 = (imm >> 5) & 127
  let b3 = 209 // 0xD1
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode MUL: MUL Xd, Xn, Xm (MADD Xd, Xn, Xm, XZR)
/// Opcode: 0x9B007C00
pub fn emit_mul(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  // sf=1 | 00 | 11011 | 000 | Rm | 0 | Ra=11111 | Rn | Rd
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 248 // Ra=11111, bit pattern 0xF8
  let mul_124 = 124 // 0x7C
  let b2 = (mul_124 | ((rm & 15) << 4)) & 255
  let b3 = 155 // 0x9B
  let mul_155 = 155
  mc.emit_inst(b0, b1, b2, (((rm >> 4) | (b3 & 240)) & 255) | mul_155)
}

///|
/// Encode SDIV: SDIV Xd, Xn, Xm
/// Opcode: 0x9AC00C00
pub fn emit_sdiv(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  // Encoding: sf=1 | 0 | 0 | 11010110 | Rm | 00001 | 1 | Rn | Rd
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 24 // 00001 | 1 pattern = 0x18
  let c0 = 192 // 0xC0
  let b2 = (c0 | (rm & 15)) & 255
  let x9a = 154 // 0x9A
  let b3 = x9a | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode UDIV: UDIV Xd, Xn, Xm
/// Opcode: 0x9AC00800
pub fn emit_udiv(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 16 // 00001 | 0 pattern = 0x10
  let c0 = 192 // 0xC0
  let b2 = (c0 | (rm & 15)) & 255
  let x9a = 154 // 0x9A
  let b3 = x9a | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode AND (shifted register): AND Xd, Xn, Xm
/// Opcode: 0x8A000000
pub fn emit_and_reg(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((rm & 15) << 4)
  let b2 = (rm >> 4) & 1
  let b3 = 138 // 0x8A
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode ORR (shifted register): ORR Xd, Xn, Xm
/// Opcode: 0xAA000000
pub fn emit_orr_reg(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((rm & 15) << 4)
  let b2 = (rm >> 4) & 1
  let b3 = 170 // 0xAA
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode EOR (shifted register): EOR Xd, Xn, Xm
/// Opcode: 0xCA000000
pub fn emit_eor_reg(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((rm & 15) << 4)
  let b2 = (rm >> 4) & 1
  let b3 = 202 // 0xCA
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode LSL (register): LSLV Xd, Xn, Xm
/// Opcode: 0x9AC02000
pub fn emit_lsl_reg(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 64 // 0010 | 00 = 0x40
  let c0 = 192 // 0xC0
  let b2 = (c0 | (rm & 15)) & 255
  let x9a = 154 // 0x9A
  let b3 = x9a | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode ASR (register): ASRV Xd, Xn, Xm
/// Opcode: 0x9AC02800
pub fn emit_asr_reg(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 80 // 0010 | 10 = 0x50
  let c0 = 192 // 0xC0
  let b2 = (c0 | (rm & 15)) & 255
  let x9a = 154 // 0x9A
  let b3 = x9a | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode LSR (register): LSRV Xd, Xn, Xm
/// Opcode: 0x9AC02400
pub fn emit_lsr_reg(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 72 // 0010 | 01 = 0x48
  let c0 = 192 // 0xC0
  let b2 = (c0 | (rm & 15)) & 255
  let x9a = 154 // 0x9A
  let b3 = x9a | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode MOV (register): MOV Xd, Xm (ORR Xd, XZR, Xm)
pub fn emit_mov_reg(mc : MachineCode, rd : Int, rm : Int) -> Unit {
  emit_orr_reg(mc, rd, 31, rm)
}

///|
/// Encode MOVZ: MOVZ Xd, #imm16, LSL #shift
/// Opcode: 0xD2800000
pub fn emit_movz(mc : MachineCode, rd : Int, imm16 : Int, shift : Int) -> Unit {
  let hw = shift / 16
  let imm = imm16 & 0xFFFF
  let b0 = (rd & 31) | ((imm & 7) << 5)
  let b1 = (imm >> 3) & 255
  let b2 = ((imm >> 11) & 31) | ((hw & 3) << 5)
  let xd2 = 210 // 0xD2
  let b3 = xd2 | ((hw >> 2) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode MOVK: MOVK Xd, #imm16, LSL #shift
/// Opcode: 0xF2800000
pub fn emit_movk(mc : MachineCode, rd : Int, imm16 : Int, shift : Int) -> Unit {
  let hw = shift / 16
  let imm = imm16 & 0xFFFF
  let b0 = (rd & 31) | ((imm & 7) << 5)
  let b1 = (imm >> 3) & 255
  let b2 = ((imm >> 11) & 31) | ((hw & 3) << 5)
  let xf2 = 242 // 0xF2
  let b3 = xf2 | ((hw >> 2) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Load a 64-bit immediate using MOVZ/MOVK sequence
pub fn emit_load_imm64(mc : MachineCode, rd : Int, imm : Int64) -> Unit {
  let v = imm.to_int()
  let v0 = v & 0xFFFF
  let v1 = (v >> 16) & 0xFFFF
  let v2 = (v >> 32) & 0xFFFF
  let v3 = (v >> 48) & 0xFFFF
  let mut started = false
  if v0 != 0 || (v1 == 0 && v2 == 0 && v3 == 0) {
    emit_movz(mc, rd, v0, 0)
    started = true
  }
  if v1 != 0 {
    if started {
      emit_movk(mc, rd, v1, 16)
    } else {
      emit_movz(mc, rd, v1, 16)
      started = true
    }
  }
  if v2 != 0 {
    if started {
      emit_movk(mc, rd, v2, 32)
    } else {
      emit_movz(mc, rd, v2, 32)
      started = true
    }
  }
  if v3 != 0 {
    if started {
      emit_movk(mc, rd, v3, 48)
    } else {
      emit_movz(mc, rd, v3, 48)
    }
  }
}

// ============ Load/Store Instructions ============

///|
/// Encode LDR (64-bit, unsigned offset): LDR Xt, [Xn, #imm]
/// Opcode: 0xF9400000
pub fn emit_ldr_imm(mc : MachineCode, rt : Int, rn : Int, imm12 : Int) -> Unit {
  let scaled = (imm12 / 8) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = (scaled >> 5) & 127
  let xf9 = 249 // 0xF9
  let b3 = xf9 | ((scaled >> 12) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode STR (64-bit, unsigned offset): STR Xt, [Xn, #imm]
/// Opcode: 0xF9000000
pub fn emit_str_imm(mc : MachineCode, rt : Int, rn : Int, imm12 : Int) -> Unit {
  let scaled = (imm12 / 8) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = (scaled >> 5) & 127
  let b3 = 249 // 0xF9
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode LDRB (unsigned offset): LDRB Wt, [Xn, #imm]
/// Opcode: 0x39400000
pub fn emit_ldrb_imm(mc : MachineCode, rt : Int, rn : Int, imm12 : Int) -> Unit {
  let imm = imm12 & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((imm & 31) << 3)
  let b2 = ((imm >> 5) & 127) | 64 // bit pattern for LDR = 0x40
  let b3 = 57 // 0x39
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode LDRH (unsigned offset): LDRH Wt, [Xn, #imm]
/// Opcode: 0x79400000
pub fn emit_ldrh_imm(mc : MachineCode, rt : Int, rn : Int, imm12 : Int) -> Unit {
  let scaled = (imm12 / 2) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = ((scaled >> 5) & 127) | 64 // 0x40
  let b3 = 121 // 0x79
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode LDR (32-bit, unsigned offset): LDR Wt, [Xn, #imm]
/// Opcode: 0xB9400000
pub fn emit_ldr_w_imm(
  mc : MachineCode,
  rt : Int,
  rn : Int,
  imm12 : Int,
) -> Unit {
  let scaled = (imm12 / 4) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = ((scaled >> 5) & 127) | 64 // 0x40
  let b3 = 185 // 0xB9
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode STRB (unsigned offset): STRB Wt, [Xn, #imm]
/// Opcode: 0x39000000
pub fn emit_strb_imm(mc : MachineCode, rt : Int, rn : Int, imm12 : Int) -> Unit {
  let imm = imm12 & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((imm & 31) << 3)
  let b2 = (imm >> 5) & 127
  let b3 = 57 // 0x39
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode STRH (unsigned offset): STRH Wt, [Xn, #imm]
/// Opcode: 0x79000000
pub fn emit_strh_imm(mc : MachineCode, rt : Int, rn : Int, imm12 : Int) -> Unit {
  let scaled = (imm12 / 2) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = (scaled >> 5) & 127
  let b3 = 121 // 0x79
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode STR (32-bit, unsigned offset): STR Wt, [Xn, #imm]
/// Opcode: 0xB9000000
pub fn emit_str_w_imm(
  mc : MachineCode,
  rt : Int,
  rn : Int,
  imm12 : Int,
) -> Unit {
  let scaled = (imm12 / 4) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = (scaled >> 5) & 127
  let b3 = 185 // 0xB9
  mc.emit_inst(b0, b1, b2, b3)
}

// ============ Branch Instructions ============

///|
/// Encode B (unconditional branch): B label
/// Opcode: 0x14000000
pub fn emit_b(mc : MachineCode, target_block : Int) -> Unit {
  mc.emit_inst(0, 0, 0, 20) // 0x14
  mc.add_fixup(target_block, Branch26)
}

///|
/// Encode B.cond (conditional branch): B.cond label
/// Opcode: 0x54000000
pub fn emit_b_cond(mc : MachineCode, cond : Int, target_block : Int) -> Unit {
  mc.emit_inst(cond & 15, 0, 0, 84) // 0x54
  mc.add_fixup(target_block, Branch19)
}

///|
/// Encode CBZ: CBZ Xt, label
/// Opcode: 0xB4000000
pub fn emit_cbz(mc : MachineCode, rt : Int, target_block : Int) -> Unit {
  mc.emit_inst(rt & 31, 0, 0, 180) // 0xB4
  mc.add_fixup(target_block, Branch19)
}

///|
/// Encode CBNZ: CBNZ Xt, label
/// Opcode: 0xB5000000
pub fn emit_cbnz(mc : MachineCode, rt : Int, target_block : Int) -> Unit {
  mc.emit_inst(rt & 31, 0, 0, 181) // 0xB5
  mc.add_fixup(target_block, Branch19)
}

///|
/// Encode RET: RET Xn
/// Opcode: 0xD65F0000 (with Rn in bits [9:5])
pub fn emit_ret(mc : MachineCode, rn : Int) -> Unit {
  let b0 = (rn & 3) << 5
  let b1 = (rn >> 2) & 7
  mc.emit_inst(b0, b1, 95, 214) // 0x5F, 0xD6
}

///|
/// Encode BL (branch with link): BL label
/// Opcode: 0x94000000
pub fn emit_bl(mc : MachineCode, target_block : Int) -> Unit {
  mc.emit_inst(0, 0, 0, 148) // 0x94
  mc.add_fixup(target_block, Branch26)
}

// ============ Comparison Instructions ============

///|
/// Encode CMP (register): CMP Xn, Xm (SUBS XZR, Xn, Xm)
/// Opcode: 0xEB00001F
pub fn emit_cmp_reg(mc : MachineCode, rn : Int, rm : Int) -> Unit {
  // SUBS with Rd=31 (XZR)
  let x1f = 31 // 0x1F
  let b0 = x1f | ((rn & 3) << 5) // Rd=31
  let b1 = ((rn >> 2) & 7) | ((rm & 15) << 4)
  let b2 = (rm >> 4) & 1
  let b3 = 235 // 0xEB
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode CMP (immediate): CMP Xn, #imm12 (SUBS XZR, Xn, #imm12)
/// Opcode: 0xF100001F
pub fn emit_cmp_imm(mc : MachineCode, rn : Int, imm12 : Int) -> Unit {
  let imm = imm12 & 0xFFF
  let x1f = 31 // 0x1F
  let b0 = x1f | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((imm & 31) << 3)
  let b2 = (imm >> 5) & 127
  let b3 = 241 // 0xF1
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode CSET: CSET Xd, cond (CSINC Xd, XZR, XZR, invert(cond))
/// Opcode: 0x9A9F0400
pub fn emit_cset(mc : MachineCode, rd : Int, cond : Int) -> Unit {
  let inv_cond = cond ^ 1
  // CSINC Xd, XZR, XZR, inv_cond
  // Encoding: sf=1 | 00 | 11010100 | Rm=11111 | cond | 0 | 1 | Rn=11111 | Rd
  let xe0 = 224 // Rn=11111 bits [1:0] shifted = 0xE0
  let b0 = (rd & 31) | xe0
  let x07 = 7
  let x04 = 4 // cond and opcode bits
  let b1 = x07 | ((inv_cond & 15) << 4) | x04
  let b2 = 159 // Rm=11111 = 0x9F
  let b3 = 154 // 0x9A
  mc.emit_inst(b0, b1, b2, b3)
}

// ============ Floating-Point Instructions ============

///|
/// Encode FADD (double): FADD Dd, Dn, Dm
/// Opcode: 0x1E602800
pub fn emit_fadd_d(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 40 // 0x28
  let x60 = 96 // 0x60
  let x6f = 111 // 0x6F
  let b2 = (x60 | (rm & 15)) & x6f
  let x1e = 30 // 0x1E
  let b3 = x1e | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode FSUB (double): FSUB Dd, Dn, Dm
/// Opcode: 0x1E603800
pub fn emit_fsub_d(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 56 // 0x38
  let x60 = 96 // 0x60
  let x6f = 111 // 0x6F
  let b2 = (x60 | (rm & 15)) & x6f
  let x1e = 30 // 0x1E
  let b3 = x1e | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode FMUL (double): FMUL Dd, Dn, Dm
/// Opcode: 0x1E600800
pub fn emit_fmul_d(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 8 // 0x08
  let x60 = 96 // 0x60
  let x6f = 111 // 0x6F
  let b2 = (x60 | (rm & 15)) & x6f
  let x1e = 30 // 0x1E
  let b3 = x1e | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode FDIV (double): FDIV Dd, Dn, Dm
/// Opcode: 0x1E601800
pub fn emit_fdiv_d(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 24 // 0x18
  let x60 = 96 // 0x60
  let x6f = 111 // 0x6F
  let b2 = (x60 | (rm & 15)) & x6f
  let x1e = 30 // 0x1E
  let b3 = x1e | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode FMOV (double, register): FMOV Dd, Dm
/// Opcode: 0x1E604000
pub fn emit_fmov_d(mc : MachineCode, rd : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rm & 3) << 5)
  let b1 = ((rm >> 2) & 7) | 64 // 0x40
  let b2 = 96 // 0x60
  let b3 = 30 // 0x1E
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode LDR (double, unsigned offset): LDR Dt, [Xn, #imm]
/// Opcode: 0xFD400000
pub fn emit_ldr_d_imm(
  mc : MachineCode,
  rt : Int,
  rn : Int,
  imm12 : Int,
) -> Unit {
  let scaled = (imm12 / 8) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = ((scaled >> 5) & 127) | 64 // 0x40
  let b3 = 253 // 0xFD
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode STR (double, unsigned offset): STR Dt, [Xn, #imm]
/// Opcode: 0xFD000000
pub fn emit_str_d_imm(
  mc : MachineCode,
  rt : Int,
  rn : Int,
  imm12 : Int,
) -> Unit {
  let scaled = (imm12 / 8) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = (scaled >> 5) & 127
  let b3 = 253 // 0xFD
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode FCMP (double): FCMP Dn, Dm
/// Opcode: 0x1E602000
pub fn emit_fcmp_d(mc : MachineCode, rn : Int, rm : Int) -> Unit {
  let b0 = (rn & 3) << 5
  let b1 = ((rn >> 2) & 7) | 32 // 0x20
  let x60 = 96 // 0x60
  let x6f = 111 // 0x6F
  let b2 = (x60 | (rm & 15)) & x6f
  let x1e = 30 // 0x1E
  let b3 = x1e | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

// ============ NOP ============

///|
/// Encode NOP
/// Opcode: 0xD503201F
pub fn emit_nop(mc : MachineCode) -> Unit {
  mc.emit_inst(31, 32, 3, 213) // 0x1F, 0x20, 0x03, 0xD5
}

// ============ Condition Codes ============

///|
pub fn cond_eq() -> Int {
  0
}

///|
pub fn cond_ne() -> Int {
  1
}

///|
pub fn cond_hs() -> Int {
  2
}

///|
pub fn cond_lo() -> Int {
  3
}

///|
pub fn cond_mi() -> Int {
  4
}

///|
pub fn cond_pl() -> Int {
  5
}

///|
pub fn cond_vs() -> Int {
  6
}

///|
pub fn cond_vc() -> Int {
  7
}

///|
pub fn cond_hi() -> Int {
  8
}

///|
pub fn cond_ls() -> Int {
  9
}

///|
pub fn cond_ge() -> Int {
  10
}

///|
pub fn cond_lt() -> Int {
  11
}

///|
pub fn cond_gt() -> Int {
  12
}

///|
pub fn cond_le() -> Int {
  13
}

///|
pub fn cond_al() -> Int {
  14
}

// ============ VCode to Machine Code ============

///|
/// Emit machine code for a VCode function
pub fn emit_function(func : VCodeFunction) -> MachineCode {
  let mc = MachineCode::new()
  for block in func.blocks {
    mc.define_label(block.id)
    for inst in block.insts {
      emit_instruction(mc, inst)
    }
    match block.terminator {
      Some(term) => emit_terminator(mc, term)
      None => ()
    }
  }
  mc.resolve_fixups()
  mc
}

///|
fn emit_instruction(mc : MachineCode, inst : VCodeInst) -> Unit {
  match inst.opcode {
    Add => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_add_reg(mc, rd, rn, rm)
    }
    Sub => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_sub_reg(mc, rd, rn, rm)
    }
    Mul => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_mul(mc, rd, rn, rm)
    }
    SDiv => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_sdiv(mc, rd, rn, rm)
    }
    UDiv => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_udiv(mc, rd, rn, rm)
    }
    And => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_and_reg(mc, rd, rn, rm)
    }
    Or => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_orr_reg(mc, rd, rn, rm)
    }
    Xor => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_eor_reg(mc, rd, rn, rm)
    }
    Shl => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_lsl_reg(mc, rd, rn, rm)
    }
    AShr => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_asr_reg(mc, rd, rn, rm)
    }
    LShr => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_lsr_reg(mc, rd, rn, rm)
    }
    FAdd => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_fadd_d(mc, rd, rn, rm)
    }
    FSub => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_fsub_d(mc, rd, rn, rm)
    }
    FMul => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_fmul_d(mc, rd, rn, rm)
    }
    FDiv => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_fdiv_d(mc, rd, rn, rm)
    }
    Load(ty, offset) => {
      let rt = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      emit_load(mc, ty, rt, rn, offset)
    }
    Store(ty, offset) => {
      let rt = reg_num(inst.uses[0])
      let rn = reg_num(inst.uses[1])
      emit_store(mc, ty, rt, rn, offset)
    }
    Move => {
      let rd = wreg_num(inst.defs[0])
      let rm = reg_num(inst.uses[0])
      emit_mov_reg(mc, rd, rm)
    }
    LoadConst(v) => {
      let rd = wreg_num(inst.defs[0])
      emit_load_imm64(mc, rd, v)
    }
    LoadConstF(_) => emit_nop(mc)
    Cmp(kind) => {
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_cmp_reg(mc, rn, rm)
      let rd = wreg_num(inst.defs[0])
      let cond = cmp_kind_to_cond(kind)
      emit_cset(mc, rd, cond)
    }
    FCmp(kind) => {
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_fcmp_d(mc, rn, rm)
      let rd = wreg_num(inst.defs[0])
      let cond = fcmp_kind_to_cond(kind)
      emit_cset(mc, rd, cond)
    }
    Extend(_) | Truncate | IntToFloat | FloatToInt => emit_nop(mc)
    Nop => emit_nop(mc)
  }
}

///|
fn emit_load(
  mc : MachineCode,
  ty : MemType,
  rt : Int,
  rn : Int,
  offset : Int,
) -> Unit {
  match ty {
    I8 => emit_ldrb_imm(mc, rt, rn, offset)
    I16 => emit_ldrh_imm(mc, rt, rn, offset)
    I32 => emit_ldr_w_imm(mc, rt, rn, offset)
    I64 => emit_ldr_imm(mc, rt, rn, offset)
    F32 | F64 => emit_ldr_d_imm(mc, rt, rn, offset)
  }
}

///|
fn emit_store(
  mc : MachineCode,
  ty : MemType,
  rt : Int,
  rn : Int,
  offset : Int,
) -> Unit {
  match ty {
    I8 => emit_strb_imm(mc, rt, rn, offset)
    I16 => emit_strh_imm(mc, rt, rn, offset)
    I32 => emit_str_w_imm(mc, rt, rn, offset)
    I64 => emit_str_imm(mc, rt, rn, offset)
    F32 | F64 => emit_str_d_imm(mc, rt, rn, offset)
  }
}

///|
fn cmp_kind_to_cond(kind : CmpKind) -> Int {
  match kind {
    Eq => cond_eq()
    Ne => cond_ne()
    Slt => cond_lt()
    Sle => cond_le()
    Sgt => cond_gt()
    Sge => cond_ge()
    Ult => cond_lo()
    Ule => cond_ls()
    Ugt => cond_hi()
    Uge => cond_hs()
  }
}

///|
fn fcmp_kind_to_cond(kind : FCmpKind) -> Int {
  match kind {
    FCmpKind::Eq => cond_eq()
    FCmpKind::Ne => cond_ne()
    FCmpKind::Lt => cond_lt()
    FCmpKind::Le => cond_le()
    FCmpKind::Gt => cond_gt()
    FCmpKind::Ge => cond_ge()
  }
}

///|
fn emit_terminator(mc : MachineCode, term : VCodeTerminator) -> Unit {
  match term {
    Jump(target) => emit_b(mc, target)
    Branch(cond, then_b, else_b) => {
      let rt = reg_num(cond)
      emit_cbnz(mc, rt, then_b)
      emit_b(mc, else_b)
    }
    Return(_) => emit_ret(mc, 30)
    Trap(_) => mc.emit_inst(0, 0, 32, 212) // BRK #0 = 0xD4200000
  }
}

///|
/// Print machine code as hex dump
pub fn MachineCode::hex_dump(self : MachineCode) -> String {
  let mut result = ""
  for i, b in self.bytes {
    if i > 0 && i % 4 == 0 {
      result = result + " "
    }
    if i > 0 && i % 16 == 0 {
      result = result + "\n"
    }
    let hi = b / 16
    let lo = b % 16
    let hi_char = if hi < 10 {
      (hi + 48).unsafe_to_char().to_string()
    } else {
      (hi - 10 + 97).unsafe_to_char().to_string()
    }
    let lo_char = if lo < 10 {
      (lo + 48).unsafe_to_char().to_string()
    } else {
      (lo - 10 + 97).unsafe_to_char().to_string()
    }
    result = result + hi_char + lo_char
  }
  result
}
