// Code Emission
// Generates machine code from VCode representation
//
// This module provides:
// 1. Machine code buffer for accumulating bytes
// 2. AArch64 instruction encoding
// 3. VCode to machine code translation

// ============ Machine Code Buffer ============

///|
/// A buffer for accumulating machine code bytes
pub(all) struct MachineCode {
  bytes : Array[Int] // Using Int for bytes (0-255)
  mut pos : Int
  // Labels for branch targets
  labels : Map[Int, Int] // block_id -> offset
  // Pending fixups for forward branches
  fixups : Array[Fixup]
}

///|
/// A fixup for a forward branch
pub(all) struct Fixup {
  // Offset in the code buffer where the fixup is needed
  offset : Int
  // Target block id
  target_block : Int
  // Kind of fixup
  kind : FixupKind
}

///|
/// Kind of fixup
pub enum FixupKind {
  Branch26 // 26-bit PC-relative branch (B, BL)
  Branch19 // 19-bit PC-relative branch (B.cond, CBZ, CBNZ)
}

///|
pub fn MachineCode::new() -> MachineCode {
  { bytes: [], pos: 0, labels: {}, fixups: [] }
}

///|
/// Emit a single byte
pub fn MachineCode::emit_byte(self : MachineCode, b : Int) -> Unit {
  self.bytes.push(b & 255)
  self.pos = self.pos + 1
}

///|
/// Emit 4 bytes (instruction) as 4 separate bytes
pub fn MachineCode::emit_inst(
  self : MachineCode,
  b0 : Int,
  b1 : Int,
  b2 : Int,
  b3 : Int,
) -> Unit {
  self.emit_byte(b0)
  self.emit_byte(b1)
  self.emit_byte(b2)
  self.emit_byte(b3)
}

///|
/// Current position in the buffer
pub fn MachineCode::current_pos(self : MachineCode) -> Int {
  self.pos
}

///|
/// Define a label at the current position
pub fn MachineCode::define_label(self : MachineCode, block_id : Int) -> Unit {
  self.labels.set(block_id, self.pos)
}

///|
/// Add a fixup for a forward branch
pub fn MachineCode::add_fixup(
  self : MachineCode,
  target_block : Int,
  kind : FixupKind,
) -> Unit {
  // Fixup is at current position - 4 (since we already emitted the instruction)
  self.fixups.push({ offset: self.pos - 4, target_block, kind })
}

///|
/// Resolve all pending fixups
pub fn MachineCode::resolve_fixups(self : MachineCode) -> Unit {
  for fixup in self.fixups {
    match self.labels.get(fixup.target_block) {
      Some(target_offset) => {
        let pc_offset = (target_offset - fixup.offset) / 4 // Instructions are 4 bytes
        match fixup.kind {
          Branch26 => {
            // Patch bits [25:0] with the 26-bit offset
            // Keep opcode bits in byte 3
            let imm26 = pc_offset & 0x3FFFFFF
            self.bytes[fixup.offset] = imm26 & 255
            self.bytes[fixup.offset + 1] = (imm26 >> 8) & 255
            self.bytes[fixup.offset + 2] = (imm26 >> 16) & 255
            // Keep upper bits of byte 3 (opcode)
            let old_b3 = self.bytes[fixup.offset + 3]
            self.bytes[fixup.offset + 3] = (old_b3 & 252) | ((imm26 >> 24) & 3)
          }
          Branch19 => {
            // Patch bits [23:5] with the 19-bit offset
            let imm19 = pc_offset & 0x7FFFF
            // imm19 goes into bits [23:5], so bytes 0-2 primarily
            // Byte 0: bits [7:5] from imm19 bits [2:0], keep bits [4:0] (Rt)
            let old_b0 = self.bytes[fixup.offset]
            self.bytes[fixup.offset] = (old_b0 & 31) | ((imm19 << 5) & 224)
            self.bytes[fixup.offset + 1] = (imm19 >> 3) & 255
            self.bytes[fixup.offset + 2] = (imm19 >> 11) & 255
            // Byte 3: keep opcode, add top bits of imm19
            let old_b3 = self.bytes[fixup.offset + 3]
            self.bytes[fixup.offset + 3] = (old_b3 & 255) | 0
          }
        }
      } // imm19 high bits already covered
      None => () // Label not found, skip (should not happen in valid code)
    }
  }
}

///|
/// Get the generated bytes
pub fn MachineCode::get_bytes(self : MachineCode) -> Array[Int] {
  self.bytes
}

///|
/// Get size in bytes
pub fn MachineCode::size(self : MachineCode) -> Int {
  self.pos
}

///|
/// Align the code buffer to a given boundary
/// Pads with NOP instructions (AArch64 NOP = 0xD503201F)
pub fn MachineCode::align(self : MachineCode, alignment : Int) -> Unit {
  // alignment must be a power of 2
  guard alignment > 0 && (alignment & (alignment - 1)) == 0 else { return }
  // Pad until aligned
  while self.pos % alignment != 0 {
    emit_nop(self)
  }
}

///|
/// Align to function boundary (typically 16 bytes on AArch64)
pub fn MachineCode::align_function(self : MachineCode) -> Unit {
  self.align(16)
}

///|
/// Align to basic block boundary (typically 4 bytes for AArch64 instructions)
pub fn MachineCode::align_block(self : MachineCode) -> Unit {
  self.align(4)
}

// ============ AArch64 Instruction Encoding ============

// Helper to build instruction from fields

///|
#warnings("-unused_value")
fn build_inst(
  b3 : Int,
  b2 : Int,
  b1 : Int,
  b0 : Int,
  rd : Int,
  rn : Int,
  rm : Int,
) -> (Int, Int, Int, Int) {
  // Most AArch64 instructions have:
  // - Rd in bits [4:0]
  // - Rn in bits [9:5]
  // - Rm in bits [20:16] (for register operations)
  let byte0 = b0 | (rd & 31) | ((rn & 7) << 5)
  let byte1 = b1 | ((rn >> 3) & 3) | ((rm & 15) << 4)
  let byte2 = b2 | ((rm >> 4) & 1)
  let byte3 = b3
  (byte0, byte1, byte2, byte3)
}

// Register encoding helper

///|
fn reg_num(reg : Reg) -> Int {
  match reg {
    Physical(preg) => preg.index
    Virtual(_) => abort("Virtual register in code emission")
  }
}

// Writable register encoding helper

///|
fn wreg_num(wreg : Writable) -> Int {
  reg_num(wreg.reg)
}

///|
/// Encode ADD (shifted register): ADD Xd, Xn, Xm
/// Opcode: 0x8B000000 = 10001011 00000000 00000000 00000000
pub fn emit_add_reg(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  // sf=1 | 00 | 01011 | shift=00 | 0 | Rm[4:0] | imm6=0 | Rn[4:0] | Rd[4:0]
  // Byte 3: 0x8B = 139
  // Byte 2: 0 | Rm[4] | 0000 | Rm[3:0] >> 4
  // Byte 1: Rm[3:0] << 4 | 0 | Rn[4:2]
  // Byte 0: Rn[1:0] << 5 | Rd[4:0]
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((rm & 15) << 4)
  let b2 = (rm >> 4) & 1
  let b3 = 139 // 0x8B
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode ADD (shifted register with shift amount): ADD Xd, Xn, Xm, shift #amount
/// Opcode: 0x8B000000 (with shift bits)
/// shift: 00=LSL, 01=LSR, 10=ASR
pub fn emit_add_shifted(
  mc : MachineCode,
  rd : Int,
  rn : Int,
  rm : Int,
  shift : ShiftType,
  amount : Int,
) -> Unit {
  let shift_bits = match shift {
    Lsl => 0
    Lsr => 1
    Asr => 2
  }
  let imm6 = amount & 63
  // Encoding: sf=1 | op=0 | S=0 | 01011 | shift[1:0] | 0 | Rm | imm6 | Rn | Rd
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((imm6 & 7) << 3) | ((rm & 1) << 6)
  let b2 = ((rm >> 1) & 15) | ((shift_bits & 3) << 6)
  let b3 = 139 // 0x8B
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode SUB (shifted register with shift amount): SUB Xd, Xn, Xm, shift #amount
pub fn emit_sub_shifted(
  mc : MachineCode,
  rd : Int,
  rn : Int,
  rm : Int,
  shift : ShiftType,
  amount : Int,
) -> Unit {
  let shift_bits = match shift {
    Lsl => 0
    Lsr => 1
    Asr => 2
  }
  let imm6 = amount & 63
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((imm6 & 7) << 3) | ((rm & 1) << 6)
  let b2 = ((rm >> 1) & 15) | ((shift_bits & 3) << 6)
  let b3 = 203 // 0xCB
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode AND (shifted register with shift amount): AND Xd, Xn, Xm, shift #amount
pub fn emit_and_shifted(
  mc : MachineCode,
  rd : Int,
  rn : Int,
  rm : Int,
  shift : ShiftType,
  amount : Int,
) -> Unit {
  let shift_bits = match shift {
    Lsl => 0
    Lsr => 1
    Asr => 2
  }
  let imm6 = amount & 63
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((imm6 & 7) << 3) | ((rm & 1) << 6)
  let b2 = ((rm >> 1) & 15) | ((shift_bits & 3) << 6)
  let b3 = 138 // 0x8A
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode ORR (shifted register with shift amount): ORR Xd, Xn, Xm, shift #amount
pub fn emit_orr_shifted(
  mc : MachineCode,
  rd : Int,
  rn : Int,
  rm : Int,
  shift : ShiftType,
  amount : Int,
) -> Unit {
  let shift_bits = match shift {
    Lsl => 0
    Lsr => 1
    Asr => 2
  }
  let imm6 = amount & 63
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((imm6 & 7) << 3) | ((rm & 1) << 6)
  let b2 = ((rm >> 1) & 15) | ((shift_bits & 3) << 6)
  let b3 = 170 // 0xAA
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode EOR (shifted register with shift amount): EOR Xd, Xn, Xm, shift #amount
pub fn emit_eor_shifted(
  mc : MachineCode,
  rd : Int,
  rn : Int,
  rm : Int,
  shift : ShiftType,
  amount : Int,
) -> Unit {
  let shift_bits = match shift {
    Lsl => 0
    Lsr => 1
    Asr => 2
  }
  let imm6 = amount & 63
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((imm6 & 7) << 3) | ((rm & 1) << 6)
  let b2 = ((rm >> 1) & 15) | ((shift_bits & 3) << 6)
  let b3 = 202 // 0xCA
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode MADD: MADD Xd, Xn, Xm, Xa (Xd = Xa + Xn * Xm)
/// Opcode: 0x9B000000
pub fn emit_madd(
  mc : MachineCode,
  rd : Int,
  rn : Int,
  rm : Int,
  ra : Int,
) -> Unit {
  // Encoding: sf=1 | 00 | 11011 | 000 | Rm | o0=0 | Ra | Rn | Rd
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((ra & 31) << 3)
  let b2 = rm & 31
  let b3 = 155 // 0x9B
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode MSUB: MSUB Xd, Xn, Xm, Xa (Xd = Xa - Xn * Xm)
/// Opcode: 0x9B008000
pub fn emit_msub(
  mc : MachineCode,
  rd : Int,
  rn : Int,
  rm : Int,
  ra : Int,
) -> Unit {
  // Encoding: sf=1 | 00 | 11011 | 000 | Rm | o0=1 | Ra | Rn | Rd
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((ra & 31) << 3) | 128 // o0=1 (bit 7)
  let b2 = rm & 31
  let b3 = 155 // 0x9B
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode MNEG: MNEG Xd, Xn, Xm (Xd = -(Xn * Xm)) = MSUB Xd, Xn, Xm, XZR
/// Opcode: 0x9B00FC00
pub fn emit_mneg(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  emit_msub(mc, rd, rn, rm, 31) // XZR = register 31
}

///|
/// Encode ADD (immediate): ADD Xd, Xn, #imm12
/// Opcode: 0x91000000
pub fn emit_add_imm(mc : MachineCode, rd : Int, rn : Int, imm12 : Int) -> Unit {
  // sf=1 | 00 | 100010 | sh=0 | imm12[11:0] | Rn[4:0] | Rd[4:0]
  let imm = imm12 & 0xFFF
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((imm & 31) << 3)
  let b2 = (imm >> 5) & 127
  let b3 = 145 // 0x91
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode SUB (shifted register): SUB Xd, Xn, Xm
/// Opcode: 0xCB000000
pub fn emit_sub_reg(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((rm & 15) << 4)
  let b2 = (rm >> 4) & 1
  let b3 = 203 // 0xCB
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode SUB (immediate): SUB Xd, Xn, #imm12
/// Opcode: 0xD1000000
pub fn emit_sub_imm(mc : MachineCode, rd : Int, rn : Int, imm12 : Int) -> Unit {
  let imm = imm12 & 0xFFF
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((imm & 31) << 3)
  let b2 = (imm >> 5) & 127
  let b3 = 209 // 0xD1
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode MUL: MUL Xd, Xn, Xm (MADD Xd, Xn, Xm, XZR)
/// Opcode: 0x9B007C00
pub fn emit_mul(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  // sf=1 | 00 | 11011 | 000 | Rm | 0 | Ra=11111 | Rn | Rd
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 248 // Ra=11111, bit pattern 0xF8
  let mul_124 = 124 // 0x7C
  let b2 = (mul_124 | ((rm & 15) << 4)) & 255
  let b3 = 155 // 0x9B
  let mul_155 = 155
  mc.emit_inst(b0, b1, b2, (((rm >> 4) | (b3 & 240)) & 255) | mul_155)
}

///|
/// Encode SDIV: SDIV Xd, Xn, Xm
/// Opcode: 0x9AC00C00
pub fn emit_sdiv(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  // Encoding: sf=1 | 0 | 0 | 11010110 | Rm | 00001 | 1 | Rn | Rd
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 24 // 00001 | 1 pattern = 0x18
  let c0 = 192 // 0xC0
  let b2 = (c0 | (rm & 15)) & 255
  let x9a = 154 // 0x9A
  let b3 = x9a | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode UDIV: UDIV Xd, Xn, Xm
/// Opcode: 0x9AC00800
pub fn emit_udiv(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 16 // 00001 | 0 pattern = 0x10
  let c0 = 192 // 0xC0
  let b2 = (c0 | (rm & 15)) & 255
  let x9a = 154 // 0x9A
  let b3 = x9a | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode AND (shifted register): AND Xd, Xn, Xm
/// Opcode: 0x8A000000
pub fn emit_and_reg(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((rm & 15) << 4)
  let b2 = (rm >> 4) & 1
  let b3 = 138 // 0x8A
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode ORR (shifted register): ORR Xd, Xn, Xm
/// Opcode: 0xAA000000
pub fn emit_orr_reg(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((rm & 15) << 4)
  let b2 = (rm >> 4) & 1
  let b3 = 170 // 0xAA
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode EOR (shifted register): EOR Xd, Xn, Xm
/// Opcode: 0xCA000000
pub fn emit_eor_reg(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((rm & 15) << 4)
  let b2 = (rm >> 4) & 1
  let b3 = 202 // 0xCA
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode LSL (register): LSLV Xd, Xn, Xm
/// Opcode: 0x9AC02000
pub fn emit_lsl_reg(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 64 // 0010 | 00 = 0x40
  let c0 = 192 // 0xC0
  let b2 = (c0 | (rm & 15)) & 255
  let x9a = 154 // 0x9A
  let b3 = x9a | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode ASR (register): ASRV Xd, Xn, Xm
/// Opcode: 0x9AC02800
pub fn emit_asr_reg(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 80 // 0010 | 10 = 0x50
  let c0 = 192 // 0xC0
  let b2 = (c0 | (rm & 15)) & 255
  let x9a = 154 // 0x9A
  let b3 = x9a | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode LSR (register): LSRV Xd, Xn, Xm
/// Opcode: 0x9AC02400
pub fn emit_lsr_reg(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 72 // 0010 | 01 = 0x48
  let c0 = 192 // 0xC0
  let b2 = (c0 | (rm & 15)) & 255
  let x9a = 154 // 0x9A
  let b3 = x9a | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode MOV (register): MOV Xd, Xm (ORR Xd, XZR, Xm)
pub fn emit_mov_reg(mc : MachineCode, rd : Int, rm : Int) -> Unit {
  emit_orr_reg(mc, rd, 31, rm)
}

///|
/// Encode MOVZ: MOVZ Xd, #imm16, LSL #shift
/// Opcode: 0xD2800000
pub fn emit_movz(mc : MachineCode, rd : Int, imm16 : Int, shift : Int) -> Unit {
  let hw = shift / 16
  let imm = imm16 & 0xFFFF
  let b0 = (rd & 31) | ((imm & 7) << 5)
  let b1 = (imm >> 3) & 255
  let b2 = ((imm >> 11) & 31) | ((hw & 3) << 5) | 128 // 0x80 is part of the opcode
  let xd2 = 210 // 0xD2
  let b3 = xd2 | ((hw >> 2) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode MOVK: MOVK Xd, #imm16, LSL #shift
/// Opcode: 0xF2800000
pub fn emit_movk(mc : MachineCode, rd : Int, imm16 : Int, shift : Int) -> Unit {
  let hw = shift / 16
  let imm = imm16 & 0xFFFF
  let b0 = (rd & 31) | ((imm & 7) << 5)
  let b1 = (imm >> 3) & 255
  let b2 = ((imm >> 11) & 31) | ((hw & 3) << 5) | 128 // 0x80 is part of the opcode
  let xf2 = 242 // 0xF2
  let b3 = xf2 | ((hw >> 2) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Load a 64-bit immediate using MOVZ/MOVK sequence
pub fn emit_load_imm64(mc : MachineCode, rd : Int, imm : Int64) -> Unit {
  // Work with Int64 to avoid issues with shifts on narrower types
  let v0 = (imm & 0xFFFFL).to_int()
  let v1 = ((imm >> 16) & 0xFFFFL).to_int()
  let v2 = ((imm >> 32) & 0xFFFFL).to_int()
  let v3 = ((imm >> 48) & 0xFFFFL).to_int()
  let mut started = false
  if v0 != 0 || (v1 == 0 && v2 == 0 && v3 == 0) {
    emit_movz(mc, rd, v0, 0)
    started = true
  }
  if v1 != 0 {
    if started {
      emit_movk(mc, rd, v1, 16)
    } else {
      emit_movz(mc, rd, v1, 16)
      started = true
    }
  }
  if v2 != 0 {
    if started {
      emit_movk(mc, rd, v2, 32)
    } else {
      emit_movz(mc, rd, v2, 32)
      started = true
    }
  }
  if v3 != 0 {
    if started {
      emit_movk(mc, rd, v3, 48)
    } else {
      emit_movz(mc, rd, v3, 48)
    }
  }
}

// ============ Load/Store Instructions ============

///|
/// Encode LDR (64-bit, unsigned offset): LDR Xt, [Xn, #imm]
/// Opcode: 0xF9400000
pub fn emit_ldr_imm(mc : MachineCode, rt : Int, rn : Int, imm12 : Int) -> Unit {
  let scaled = (imm12 / 8) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = (scaled >> 5) & 127
  let xf9 = 249 // 0xF9
  let b3 = xf9 | ((scaled >> 12) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode STR (64-bit, unsigned offset): STR Xt, [Xn, #imm]
/// Opcode: 0xF9000000
pub fn emit_str_imm(mc : MachineCode, rt : Int, rn : Int, imm12 : Int) -> Unit {
  let scaled = (imm12 / 8) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = (scaled >> 5) & 127
  let b3 = 249 // 0xF9
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode LDRB (unsigned offset): LDRB Wt, [Xn, #imm]
/// Opcode: 0x39400000
pub fn emit_ldrb_imm(mc : MachineCode, rt : Int, rn : Int, imm12 : Int) -> Unit {
  let imm = imm12 & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((imm & 31) << 3)
  let b2 = ((imm >> 5) & 127) | 64 // bit pattern for LDR = 0x40
  let b3 = 57 // 0x39
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode LDRH (unsigned offset): LDRH Wt, [Xn, #imm]
/// Opcode: 0x79400000
pub fn emit_ldrh_imm(mc : MachineCode, rt : Int, rn : Int, imm12 : Int) -> Unit {
  let scaled = (imm12 / 2) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = ((scaled >> 5) & 127) | 64 // 0x40
  let b3 = 121 // 0x79
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode LDR (32-bit, unsigned offset): LDR Wt, [Xn, #imm]
/// Opcode: 0xB9400000
pub fn emit_ldr_w_imm(
  mc : MachineCode,
  rt : Int,
  rn : Int,
  imm12 : Int,
) -> Unit {
  let scaled = (imm12 / 4) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = ((scaled >> 5) & 127) | 64 // 0x40
  let b3 = 185 // 0xB9
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode STRB (unsigned offset): STRB Wt, [Xn, #imm]
/// Opcode: 0x39000000
pub fn emit_strb_imm(mc : MachineCode, rt : Int, rn : Int, imm12 : Int) -> Unit {
  let imm = imm12 & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((imm & 31) << 3)
  let b2 = (imm >> 5) & 127
  let b3 = 57 // 0x39
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode STRH (unsigned offset): STRH Wt, [Xn, #imm]
/// Opcode: 0x79000000
pub fn emit_strh_imm(mc : MachineCode, rt : Int, rn : Int, imm12 : Int) -> Unit {
  let scaled = (imm12 / 2) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = (scaled >> 5) & 127
  let b3 = 121 // 0x79
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode STR (32-bit, unsigned offset): STR Wt, [Xn, #imm]
/// Opcode: 0xB9000000
pub fn emit_str_w_imm(
  mc : MachineCode,
  rt : Int,
  rn : Int,
  imm12 : Int,
) -> Unit {
  let scaled = (imm12 / 4) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = (scaled >> 5) & 127
  let b3 = 185 // 0xB9
  mc.emit_inst(b0, b1, b2, b3)
}

// ============ Sign-Extending Load Instructions ============

///|
/// Encode LDRSB (64-bit result, unsigned offset): LDRSB Xt, [Xn, #imm]
/// Opcode: 0x39800000
pub fn emit_ldrsb_x_imm(
  mc : MachineCode,
  rt : Int,
  rn : Int,
  imm12 : Int,
) -> Unit {
  let imm = imm12 & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((imm & 31) << 3)
  let b2 = ((imm >> 5) & 127) | 128 // bit 7 = 1 for signed + 64-bit
  let b3 = 57 // 0x39
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode LDRSB (32-bit result, unsigned offset): LDRSB Wt, [Xn, #imm]
/// Opcode: 0x39C00000
pub fn emit_ldrsb_w_imm(
  mc : MachineCode,
  rt : Int,
  rn : Int,
  imm12 : Int,
) -> Unit {
  let imm = imm12 & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((imm & 31) << 3)
  let b2 = ((imm >> 5) & 127) | 192 // bit 7,6 = 11 for signed + 32-bit
  let b3 = 57 // 0x39
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode LDRSH (64-bit result, unsigned offset): LDRSH Xt, [Xn, #imm]
/// Opcode: 0x79800000
pub fn emit_ldrsh_x_imm(
  mc : MachineCode,
  rt : Int,
  rn : Int,
  imm12 : Int,
) -> Unit {
  let scaled = (imm12 / 2) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = ((scaled >> 5) & 127) | 128 // bit 7 = 1 for signed + 64-bit
  let b3 = 121 // 0x79
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode LDRSH (32-bit result, unsigned offset): LDRSH Wt, [Xn, #imm]
/// Opcode: 0x79C00000
pub fn emit_ldrsh_w_imm(
  mc : MachineCode,
  rt : Int,
  rn : Int,
  imm12 : Int,
) -> Unit {
  let scaled = (imm12 / 2) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = ((scaled >> 5) & 127) | 192 // bit 7,6 = 11 for signed + 32-bit
  let b3 = 121 // 0x79
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode LDRSW (unsigned offset): LDRSW Xt, [Xn, #imm]
/// Opcode: 0xB9800000
pub fn emit_ldrsw_imm(
  mc : MachineCode,
  rt : Int,
  rn : Int,
  imm12 : Int,
) -> Unit {
  let scaled = (imm12 / 4) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = ((scaled >> 5) & 127) | 128 // bit 7 = 1 for signed
  let b3 = 185 // 0xB9
  mc.emit_inst(b0, b1, b2, b3)
}

// ============ Branch Instructions ============

///|
/// Encode B (unconditional branch): B label
/// Opcode: 0x14000000
pub fn emit_b(mc : MachineCode, target_block : Int) -> Unit {
  mc.emit_inst(0, 0, 0, 20) // 0x14
  mc.add_fixup(target_block, Branch26)
}

///|
/// Encode B.cond (conditional branch): B.cond label
/// Opcode: 0x54000000
pub fn emit_b_cond(mc : MachineCode, cond : Int, target_block : Int) -> Unit {
  mc.emit_inst(cond & 15, 0, 0, 84) // 0x54
  mc.add_fixup(target_block, Branch19)
}

///|
/// Encode CBZ: CBZ Xt, label
/// Opcode: 0xB4000000
pub fn emit_cbz(mc : MachineCode, rt : Int, target_block : Int) -> Unit {
  mc.emit_inst(rt & 31, 0, 0, 180) // 0xB4
  mc.add_fixup(target_block, Branch19)
}

///|
/// Encode CBNZ: CBNZ Xt, label
/// Opcode: 0xB5000000
pub fn emit_cbnz(mc : MachineCode, rt : Int, target_block : Int) -> Unit {
  mc.emit_inst(rt & 31, 0, 0, 181) // 0xB5
  mc.add_fixup(target_block, Branch19)
}

///|
/// Encode RET: RET Xn
/// Opcode: 0xD65F0000 (with Rn in bits [9:5])
pub fn emit_ret(mc : MachineCode, rn : Int) -> Unit {
  // Rn goes in bits [9:5] of the instruction
  // In little-endian bytes:
  // byte0 bits [7:5] = Rn[2:0]
  // byte1 bits [2:0] = Rn[4:3]
  let b0 = (rn & 7) << 5 // Rn[2:0] in bits [7:5]
  let b1 = (rn >> 3) & 3 // Rn[4:3] in bits [1:0]
  mc.emit_inst(b0, b1, 95, 214) // 0x5F, 0xD6
}

///|
/// Encode BL (branch with link): BL label
/// Opcode: 0x94000000
pub fn emit_bl(mc : MachineCode, target_block : Int) -> Unit {
  mc.emit_inst(0, 0, 0, 148) // 0x94
  mc.add_fixup(target_block, Branch26)
}

// ============ Comparison Instructions ============

///|
/// Encode CMP (register): CMP Xn, Xm (SUBS XZR, Xn, Xm)
/// Opcode: 0xEB00001F
pub fn emit_cmp_reg(mc : MachineCode, rn : Int, rm : Int) -> Unit {
  // SUBS with Rd=31 (XZR)
  let x1f = 31 // 0x1F
  let b0 = x1f | ((rn & 3) << 5) // Rd=31
  let b1 = ((rn >> 2) & 7) | ((rm & 15) << 4)
  let b2 = (rm >> 4) & 1
  let b3 = 235 // 0xEB
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode CMP (immediate): CMP Xn, #imm12 (SUBS XZR, Xn, #imm12)
/// Opcode: 0xF100001F
pub fn emit_cmp_imm(mc : MachineCode, rn : Int, imm12 : Int) -> Unit {
  let imm = imm12 & 0xFFF
  let x1f = 31 // 0x1F
  let b0 = x1f | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((imm & 31) << 3)
  let b2 = (imm >> 5) & 127
  let b3 = 241 // 0xF1
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode CSET: CSET Xd, cond (CSINC Xd, XZR, XZR, invert(cond))
/// Opcode: 0x9A9F0400
pub fn emit_cset(mc : MachineCode, rd : Int, cond : Int) -> Unit {
  let inv_cond = cond ^ 1
  // CSINC Xd, XZR, XZR, inv_cond
  // Encoding: sf=1 | 00 | 11010100 | Rm=11111 | cond | 0 | 1 | Rn=11111 | Rd
  let xe0 = 224 // Rn=11111 bits [1:0] shifted = 0xE0
  let b0 = (rd & 31) | xe0
  let x07 = 7
  let x04 = 4 // cond and opcode bits
  let b1 = x07 | ((inv_cond & 15) << 4) | x04
  let b2 = 159 // Rm=11111 = 0x9F
  let b3 = 154 // 0x9A
  mc.emit_inst(b0, b1, b2, b3)
}

// ============ Floating-Point Instructions ============

///|
/// Encode FADD (double): FADD Dd, Dn, Dm
/// Opcode: 0x1E602800
pub fn emit_fadd_d(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 40 // 0x28
  let x60 = 96 // 0x60
  let x6f = 111 // 0x6F
  let b2 = (x60 | (rm & 15)) & x6f
  let x1e = 30 // 0x1E
  let b3 = x1e | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode FSUB (double): FSUB Dd, Dn, Dm
/// Opcode: 0x1E603800
pub fn emit_fsub_d(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 56 // 0x38
  let x60 = 96 // 0x60
  let x6f = 111 // 0x6F
  let b2 = (x60 | (rm & 15)) & x6f
  let x1e = 30 // 0x1E
  let b3 = x1e | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode FMUL (double): FMUL Dd, Dn, Dm
/// Opcode: 0x1E600800
pub fn emit_fmul_d(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 8 // 0x08
  let x60 = 96 // 0x60
  let x6f = 111 // 0x6F
  let b2 = (x60 | (rm & 15)) & x6f
  let x1e = 30 // 0x1E
  let b3 = x1e | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode FDIV (double): FDIV Dd, Dn, Dm
/// Opcode: 0x1E601800
pub fn emit_fdiv_d(mc : MachineCode, rd : Int, rn : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | 24 // 0x18
  let x60 = 96 // 0x60
  let x6f = 111 // 0x6F
  let b2 = (x60 | (rm & 15)) & x6f
  let x1e = 30 // 0x1E
  let b3 = x1e | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode FMOV (double, register): FMOV Dd, Dm
/// Opcode: 0x1E604000
pub fn emit_fmov_d(mc : MachineCode, rd : Int, rm : Int) -> Unit {
  let b0 = (rd & 31) | ((rm & 3) << 5)
  let b1 = ((rm >> 2) & 7) | 64 // 0x40
  let b2 = 96 // 0x60
  let b3 = 30 // 0x1E
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode LDR (double, unsigned offset): LDR Dt, [Xn, #imm]
/// Opcode: 0xFD400000
pub fn emit_ldr_d_imm(
  mc : MachineCode,
  rt : Int,
  rn : Int,
  imm12 : Int,
) -> Unit {
  let scaled = (imm12 / 8) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = ((scaled >> 5) & 127) | 64 // 0x40
  let b3 = 253 // 0xFD
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode STR (double, unsigned offset): STR Dt, [Xn, #imm]
/// Opcode: 0xFD000000
pub fn emit_str_d_imm(
  mc : MachineCode,
  rt : Int,
  rn : Int,
  imm12 : Int,
) -> Unit {
  let scaled = (imm12 / 8) & 0xFFF
  let b0 = (rt & 31) | ((rn & 3) << 5)
  let b1 = ((rn >> 2) & 7) | ((scaled & 31) << 3)
  let b2 = (scaled >> 5) & 127
  let b3 = 253 // 0xFD
  mc.emit_inst(b0, b1, b2, b3)
}

///|
/// Encode FCMP (double): FCMP Dn, Dm
/// Opcode: 0x1E602000
pub fn emit_fcmp_d(mc : MachineCode, rn : Int, rm : Int) -> Unit {
  let b0 = (rn & 3) << 5
  let b1 = ((rn >> 2) & 7) | 32 // 0x20
  let x60 = 96 // 0x60
  let x6f = 111 // 0x6F
  let b2 = (x60 | (rm & 15)) & x6f
  let x1e = 30 // 0x1E
  let b3 = x1e | ((rm >> 4) & 1)
  mc.emit_inst(b0, b1, b2, b3)
}

// ============ NOP ============

///|
/// Encode NOP
/// Opcode: 0xD503201F
pub fn emit_nop(mc : MachineCode) -> Unit {
  mc.emit_inst(31, 32, 3, 213) // 0x1F, 0x20, 0x03, 0xD5
}

// ============ Condition Codes ============

///|
/// AArch64 condition codes
pub(all) enum CondCode {
  EQ // Equal (Z=1)
  NE // Not equal (Z=0)
  HS // Unsigned higher or same (C=1), also CS
  LO // Unsigned lower (C=0), also CC
  MI // Minus/negative (N=1)
  PL // Plus/positive or zero (N=0)
  VS // Overflow (V=1)
  VC // No overflow (V=0)
  HI // Unsigned higher (C=1 & Z=0)
  LS // Unsigned lower or same (C=0 | Z=1)
  GE // Signed greater or equal (N=V)
  LT // Signed less than (N!=V)
  GT // Signed greater than (Z=0 & N=V)
  LE // Signed less or equal (Z=1 | N!=V)
  AL // Always
}

///|
pub fn CondCode::to_int(self : CondCode) -> Int {
  match self {
    EQ => 0
    NE => 1
    HS => 2
    LO => 3
    MI => 4
    PL => 5
    VS => 6
    VC => 7
    HI => 8
    LS => 9
    GE => 10
    LT => 11
    GT => 12
    LE => 13
    AL => 14
  }
}

// ============ VCode to Machine Code ============

///|
/// Emit machine code for a VCode function
pub fn emit_function(func : VCodeFunction) -> MachineCode {
  let mc = MachineCode::new()
  for block in func.blocks {
    mc.define_label(block.id)
    for inst in block.insts {
      emit_instruction(mc, inst)
    }
    match block.terminator {
      Some(term) => emit_terminator(mc, term)
      None => ()
    }
  }
  mc.resolve_fixups()
  mc
}

///|
fn emit_instruction(mc : MachineCode, inst : VCodeInst) -> Unit {
  match inst.opcode {
    Add => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_add_reg(mc, rd, rn, rm)
    }
    Sub => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_sub_reg(mc, rd, rn, rm)
    }
    Mul => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_mul(mc, rd, rn, rm)
    }
    SDiv => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_sdiv(mc, rd, rn, rm)
    }
    UDiv => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_udiv(mc, rd, rn, rm)
    }
    And => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_and_reg(mc, rd, rn, rm)
    }
    Or => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_orr_reg(mc, rd, rn, rm)
    }
    Xor => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_eor_reg(mc, rd, rn, rm)
    }
    Shl => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_lsl_reg(mc, rd, rn, rm)
    }
    AShr => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_asr_reg(mc, rd, rn, rm)
    }
    LShr => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_lsr_reg(mc, rd, rn, rm)
    }
    FAdd => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_fadd_d(mc, rd, rn, rm)
    }
    FSub => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_fsub_d(mc, rd, rn, rm)
    }
    FMul => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_fmul_d(mc, rd, rn, rm)
    }
    FDiv => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_fdiv_d(mc, rd, rn, rm)
    }
    Load(ty, offset) => {
      let rt = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      emit_load(mc, ty, rt, rn, offset)
    }
    Store(ty, offset) => {
      let rt = reg_num(inst.uses[0])
      let rn = reg_num(inst.uses[1])
      emit_store(mc, ty, rt, rn, offset)
    }
    // Narrow load operations (8/16/32-bit with sign/zero extension)
    Load8S(offset) => {
      let rt = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      // Sign-extend to 64-bit (use LDRSB Xt form)
      emit_ldrsb_x_imm(mc, rt, rn, offset)
    }
    Load8U(offset) => {
      let rt = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      // Zero-extend (LDRB already zero-extends)
      emit_ldrb_imm(mc, rt, rn, offset)
    }
    Load16S(offset) => {
      let rt = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      // Sign-extend to 64-bit (use LDRSH Xt form)
      emit_ldrsh_x_imm(mc, rt, rn, offset)
    }
    Load16U(offset) => {
      let rt = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      // Zero-extend (LDRH already zero-extends)
      emit_ldrh_imm(mc, rt, rn, offset)
    }
    Load32S(offset) => {
      let rt = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      // Sign-extend 32-bit to 64-bit
      emit_ldrsw_imm(mc, rt, rn, offset)
    }
    Load32U(offset) => {
      let rt = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      // Zero-extend (LDR W already zero-extends to 64-bit)
      emit_ldr_w_imm(mc, rt, rn, offset)
    }
    Move => {
      let rd = wreg_num(inst.defs[0])
      let rm = reg_num(inst.uses[0])
      emit_mov_reg(mc, rd, rm)
    }
    LoadConst(v) => {
      let rd = wreg_num(inst.defs[0])
      emit_load_imm64(mc, rd, v)
    }
    LoadConstF(_) => emit_nop(mc)
    Cmp(kind) => {
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_cmp_reg(mc, rn, rm)
      let rd = wreg_num(inst.defs[0])
      let cond = cmp_kind_to_cond(kind)
      emit_cset(mc, rd, cond)
    }
    FCmp(kind) => {
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_fcmp_d(mc, rn, rm)
      let rd = wreg_num(inst.defs[0])
      let cond = fcmp_kind_to_cond(kind)
      emit_cset(mc, rd, cond)
    }
    Extend(_) | Truncate | IntToFloat | FloatToInt => emit_nop(mc)
    Nop => emit_nop(mc)
    // AArch64-specific: shifted operand instructions
    AddShifted(shift, amount) => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_add_shifted(mc, rd, rn, rm, shift, amount)
    }
    SubShifted(shift, amount) => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_sub_shifted(mc, rd, rn, rm, shift, amount)
    }
    AndShifted(shift, amount) => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_and_shifted(mc, rd, rn, rm, shift, amount)
    }
    OrShifted(shift, amount) => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_orr_shifted(mc, rd, rn, rm, shift, amount)
    }
    XorShifted(shift, amount) => {
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_eor_shifted(mc, rd, rn, rm, shift, amount)
    }
    // AArch64-specific: multiply-accumulate instructions
    Madd => {
      // Xd = Xa + Xn * Xm, uses: [acc, src1, src2]
      let rd = wreg_num(inst.defs[0])
      let ra = reg_num(inst.uses[0]) // accumulator
      let rn = reg_num(inst.uses[1]) // multiplicand
      let rm = reg_num(inst.uses[2]) // multiplier
      emit_madd(mc, rd, rn, rm, ra)
    }
    Msub => {
      // Xd = Xa - Xn * Xm, uses: [acc, src1, src2]
      let rd = wreg_num(inst.defs[0])
      let ra = reg_num(inst.uses[0]) // accumulator
      let rn = reg_num(inst.uses[1]) // multiplicand
      let rm = reg_num(inst.uses[2]) // multiplier
      emit_msub(mc, rd, rn, rm, ra)
    }
    Mneg => {
      // Xd = -(Xn * Xm), uses: [src1, src2]
      let rd = wreg_num(inst.defs[0])
      let rn = reg_num(inst.uses[0])
      let rm = reg_num(inst.uses[1])
      emit_mneg(mc, rd, rn, rm)
    }
  }
}

///|
fn emit_load(
  mc : MachineCode,
  ty : MemType,
  rt : Int,
  rn : Int,
  offset : Int,
) -> Unit {
  match ty {
    I8 => emit_ldrb_imm(mc, rt, rn, offset)
    I16 => emit_ldrh_imm(mc, rt, rn, offset)
    I32 => emit_ldr_w_imm(mc, rt, rn, offset)
    I64 => emit_ldr_imm(mc, rt, rn, offset)
    F32 | F64 => emit_ldr_d_imm(mc, rt, rn, offset)
  }
}

///|
fn emit_store(
  mc : MachineCode,
  ty : MemType,
  rt : Int,
  rn : Int,
  offset : Int,
) -> Unit {
  match ty {
    I8 => emit_strb_imm(mc, rt, rn, offset)
    I16 => emit_strh_imm(mc, rt, rn, offset)
    I32 => emit_str_w_imm(mc, rt, rn, offset)
    I64 => emit_str_imm(mc, rt, rn, offset)
    F32 | F64 => emit_str_d_imm(mc, rt, rn, offset)
  }
}

///|
fn cmp_kind_to_cond(kind : CmpKind) -> Int {
  match kind {
    Eq => EQ.to_int()
    Ne => NE.to_int()
    Slt => LT.to_int()
    Sle => LE.to_int()
    Sgt => GT.to_int()
    Sge => GE.to_int()
    Ult => LO.to_int()
    Ule => LS.to_int()
    Ugt => HI.to_int()
    Uge => HS.to_int()
  }
}

///|
fn fcmp_kind_to_cond(kind : FCmpKind) -> Int {
  match kind {
    FCmpKind::Eq => EQ.to_int()
    FCmpKind::Ne => NE.to_int()
    FCmpKind::Lt => LT.to_int()
    FCmpKind::Le => LE.to_int()
    FCmpKind::Gt => GT.to_int()
    FCmpKind::Ge => GE.to_int()
  }
}

///|
fn emit_terminator(mc : MachineCode, term : VCodeTerminator) -> Unit {
  match term {
    Jump(target) => emit_b(mc, target)
    Branch(cond, then_b, else_b) => {
      let rt = reg_num(cond)
      emit_cbnz(mc, rt, then_b)
      emit_b(mc, else_b)
    }
    Return(_) => emit_ret(mc, 30)
    Trap(_) => mc.emit_inst(0, 0, 32, 212) // BRK #0 = 0xD4200000
  }
}

///|
/// Print machine code as hex dump
pub fn MachineCode::hex_dump(self : MachineCode) -> String {
  let mut result = ""
  for i, b in self.bytes {
    if i > 0 && i % 4 == 0 {
      result = result + " "
    }
    if i > 0 && i % 16 == 0 {
      result = result + "\n"
    }
    let hi = b / 16
    let lo = b % 16
    let hi_char = if hi < 10 {
      (hi + 48).unsafe_to_char().to_string()
    } else {
      (hi - 10 + 97).unsafe_to_char().to_string()
    }
    let lo_char = if lo < 10 {
      (lo + 48).unsafe_to_char().to_string()
    } else {
      (lo - 10 + 97).unsafe_to_char().to_string()
    }
    result = result + hi_char + lo_char
  }
  result
}
