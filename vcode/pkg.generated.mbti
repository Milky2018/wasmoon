// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/wasmoon/vcode"

import(
  "Milky2018/wasmoon/vcode/abi"
  "Milky2018/wasmoon/vcode/block"
  "Milky2018/wasmoon/vcode/emit"
  "Milky2018/wasmoon/vcode/instr"
  "Milky2018/wasmoon/vcode/lower"
)

// Values
pub const ABI_VERSION : Int = 2

pub const CTX_FUNC_TABLE_OFFSET : Int = 0

pub const CTX_INDIRECT_TABLE_OFFSET : Int = 8

pub const CTX_MEMORY_BASE_OFFSET : Int = 16

pub const CTX_MEMORY_SIZE_OFFSET : Int = 24

pub const FLOAT_PARAM_BASE_REG : Int = 0

pub const LEGACY_MAX_REG_PARAMS : Int = 8

pub const LEGACY_PARAM_BASE_REG : Int = 3

pub const MAX_FLOAT_REG_PARAMS : Int = 8

pub const MAX_REG_PARAMS : Int = 8

pub const PARAM_BASE_REG : Int = 0

pub const REG_CONTEXT : Int = 20

pub const REG_EXTRA_RESULTS : Int = 23

pub const REG_INDIRECT_TABLE : Int = 24

pub const REG_MEMORY_BASE : Int = 21

pub const REG_MEMORY_SIZE : Int = 22

pub const SCRATCH_REG_1 : Int = 16

pub const SCRATCH_REG_2 : Int = 17

pub fn dump_regalloc(String, @lower.LivenessResult, @lower.RegAllocResult) -> Unit

pub fn dump_vcode(@lower.VCodeFunction, String) -> Unit

// Errors

// Types and methods
pub(all) struct AArch64 {
  name : String
}
pub fn AArch64::new() -> Self
pub impl TargetISA for AArch64

pub(all) struct AArch64Regs {
  placeholder : Int
}
pub fn AArch64Regs::d0(Self) -> @abi.PReg
pub fn AArch64Regs::d1(Self) -> @abi.PReg
pub fn AArch64Regs::d2(Self) -> @abi.PReg
pub fn AArch64Regs::d3(Self) -> @abi.PReg
pub fn AArch64Regs::d4(Self) -> @abi.PReg
pub fn AArch64Regs::d5(Self) -> @abi.PReg
pub fn AArch64Regs::d6(Self) -> @abi.PReg
pub fn AArch64Regs::d7(Self) -> @abi.PReg
pub fn AArch64Regs::fp(Self) -> @abi.PReg
pub fn AArch64Regs::lr(Self) -> @abi.PReg
pub fn AArch64Regs::new() -> Self
pub fn AArch64Regs::x0(Self) -> @abi.PReg
pub fn AArch64Regs::x1(Self) -> @abi.PReg
pub fn AArch64Regs::x2(Self) -> @abi.PReg
pub fn AArch64Regs::x3(Self) -> @abi.PReg
pub fn AArch64Regs::x4(Self) -> @abi.PReg
pub fn AArch64Regs::x5(Self) -> @abi.PReg
pub fn AArch64Regs::x6(Self) -> @abi.PReg
pub fn AArch64Regs::x7(Self) -> @abi.PReg

pub enum CallConv {
  SystemV
  WindowsFastcall
  Aapcs64
  Wasm
}
pub impl Show for CallConv

pub(all) struct CodeCache {
  functions : Map[Int, CompiledFunction]
  mut total_size : Int
  max_size : Int
  mut hits : Int
  mut misses : Int
}
pub fn CodeCache::clear(Self) -> Unit
pub fn CodeCache::contains(Self, Int) -> Bool
pub fn CodeCache::get(Self, Int) -> CompiledFunction?
pub fn CodeCache::insert(Self, Int, CompiledFunction) -> Unit
pub fn CodeCache::invalidate(Self, Int) -> Unit
pub fn CodeCache::new(Int) -> Self
pub fn CodeCache::remove(Self, Int) -> Unit
pub fn CodeCache::stats(Self) -> (Int, Int, Int, Int)
pub impl Show for CodeCache

pub(all) struct CompiledFunction {
  name : String
  code : @emit.MachineCode
  entry_offset : Int
  code_size : Int
  frame_size : Int
  mut valid : Bool
}
pub fn CompiledFunction::get_code(Self) -> Array[Int]
pub fn CompiledFunction::invalidate(Self) -> Unit
pub fn CompiledFunction::is_valid(Self) -> Bool
pub fn CompiledFunction::new(String, @emit.MachineCode, Int) -> Self
pub impl Show for CompiledFunction

pub(all) struct ExecutableRegion {
  id : Int
  base_addr : Int
  size : Int
  mut write_pos : Int
  code : Array[Int]
  mut finalized : Bool
}
pub fn ExecutableRegion::address_at(Self, Int) -> Int
pub fn ExecutableRegion::finalize(Self) -> Unit
pub fn ExecutableRegion::new(Int, Int) -> Self
pub fn ExecutableRegion::read_at(Self, Int, Int) -> Array[Int]
pub fn ExecutableRegion::remaining(Self) -> Int
pub fn ExecutableRegion::write(Self, Array[Int]) -> Result[Int, String]
pub impl Show for ExecutableRegion

pub(all) struct JITRuntime {
  cache : CodeCache
  memory : MemoryManager
  mut compilations : Int
  mut recompilations : Int
}
pub fn JITRuntime::clear(Self) -> Unit
pub fn JITRuntime::invalidate(Self, Int) -> Unit
pub fn JITRuntime::lookup(Self, Int) -> CompiledFunction?
pub fn JITRuntime::new(Int, Int) -> Self
pub fn JITRuntime::register(Self, Int, CompiledFunction) -> Result[Int, String]
pub fn JITRuntime::stats(Self) -> (Int, Int, Int, Int, Int, Int, Int)
pub impl Show for JITRuntime

pub(all) struct MemoryManager {
  regions : Array[ExecutableRegion]
  default_region_size : Int
  mut next_id : Int
  mut current_region : Int?
}
pub fn MemoryManager::alloc_region(Self, Int) -> ExecutableRegion
pub fn MemoryManager::finalize_all(Self) -> Unit
pub fn MemoryManager::get_current_region(Self) -> ExecutableRegion
pub fn MemoryManager::new(Int) -> Self
pub fn MemoryManager::total_allocated(Self) -> Int
pub fn MemoryManager::total_used(Self) -> Int
pub fn MemoryManager::write_code(Self, @emit.MachineCode) -> Result[(ExecutableRegion, Int), String]
pub impl Show for MemoryManager

pub(all) struct VCodeBuilder {
  func : @lower.VCodeFunction
  mut current_block : @block.VCodeBlock?
}
pub fn VCodeBuilder::add(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::add_param(Self, @abi.RegClass) -> @abi.VReg
pub fn VCodeBuilder::add_result(Self, @abi.RegClass) -> Unit
pub fn VCodeBuilder::ashr(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::band(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::bor(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::branch(Self, @abi.VReg, @block.VCodeBlock, @block.VCodeBlock) -> Unit
pub fn VCodeBuilder::bxor(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::cmp(Self, @instr.CmpKind, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::create_block(Self) -> @block.VCodeBlock
pub fn VCodeBuilder::current_block(Self) -> @block.VCodeBlock?
pub fn VCodeBuilder::fadd(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::fcmp(Self, @instr.FCmpKind, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::fconst(Self, Double) -> @abi.VReg
pub fn VCodeBuilder::fdiv(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::fmul(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::fsub(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::get_function(Self) -> @lower.VCodeFunction
pub fn VCodeBuilder::iconst(Self, Int64) -> @abi.VReg
pub fn VCodeBuilder::jump(Self, @block.VCodeBlock) -> Unit
pub fn VCodeBuilder::load(Self, @instr.MemType, @abi.VReg, Int) -> @abi.VReg
pub fn VCodeBuilder::lshr(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::mov(Self, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::mul(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::new(String) -> Self
pub fn VCodeBuilder::print(Self) -> String
pub fn VCodeBuilder::return_(Self, Array[@abi.VReg]) -> Unit
pub fn VCodeBuilder::sdiv(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::shl(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::store(Self, @instr.MemType, @abi.VReg, @abi.VReg, Int) -> Unit
pub fn VCodeBuilder::sub(Self, @abi.VReg, @abi.VReg) -> @abi.VReg
pub fn VCodeBuilder::switch_to_block(Self, @block.VCodeBlock) -> Unit
pub fn VCodeBuilder::trap(Self, String) -> Unit
pub fn VCodeBuilder::udiv(Self, @abi.VReg, @abi.VReg) -> @abi.VReg

// Type aliases

// Traits
pub(open) trait TargetISA {
  name(Self) -> String
  gpr_count(Self) -> Int
  fpr_count(Self) -> Int
  get_preg(Self, @abi.RegClass, Int) -> @abi.PReg?
  pointer_size(Self) -> Int
}

