// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/wasmoon/vcode"

import(
  "Milky2018/wasmoon/ir"
  "moonbitlang/core/set"
)

// Values
fn aapcs64_arg_fprs() -> Array[PReg]

fn aapcs64_arg_gprs() -> Array[PReg]

fn aapcs64_callee_saved() -> Array[PReg]

fn aapcs64_caller_saved() -> Array[PReg]

fn aapcs64_ret_fprs() -> Array[PReg]

fn aapcs64_ret_gprs() -> Array[PReg]

fn allocate_registers_aarch64(VCodeFunction) -> VCodeFunction

fn apply_aarch64_rule(String, MatchResult, @ir.Inst, LoweringContext) -> AArch64RewriteResult

fn apply_allocation(VCodeFunction, RegAllocResult) -> VCodeFunction

fn build_stack_layout_aarch64(RegAllocResult, VCodeFunction) -> AArch64StackFrame

fn compute_liveness(VCodeFunction) -> LivenessResult

fn cond_al() -> Int

fn cond_eq() -> Int

fn cond_ge() -> Int

fn cond_gt() -> Int

fn cond_hi() -> Int

fn cond_hs() -> Int

fn cond_le() -> Int

fn cond_lo() -> Int

fn cond_ls() -> Int

fn cond_lt() -> Int

fn cond_mi() -> Int

fn cond_ne() -> Int

fn cond_pl() -> Int

fn cond_vc() -> Int

fn cond_vs() -> Int

fn emit_add_imm(MachineCode, Int, Int, Int) -> Unit

fn emit_add_reg(MachineCode, Int, Int, Int) -> Unit

fn emit_and_reg(MachineCode, Int, Int, Int) -> Unit

fn emit_asr_reg(MachineCode, Int, Int, Int) -> Unit

fn emit_b(MachineCode, Int) -> Unit

fn emit_b_cond(MachineCode, Int, Int) -> Unit

fn emit_bl(MachineCode, Int) -> Unit

fn emit_cbnz(MachineCode, Int, Int) -> Unit

fn emit_cbz(MachineCode, Int, Int) -> Unit

fn emit_cmp_imm(MachineCode, Int, Int) -> Unit

fn emit_cmp_reg(MachineCode, Int, Int) -> Unit

fn emit_cset(MachineCode, Int, Int) -> Unit

fn emit_eor_reg(MachineCode, Int, Int, Int) -> Unit

fn emit_fadd_d(MachineCode, Int, Int, Int) -> Unit

fn emit_fcmp_d(MachineCode, Int, Int) -> Unit

fn emit_fdiv_d(MachineCode, Int, Int, Int) -> Unit

fn emit_fmov_d(MachineCode, Int, Int) -> Unit

fn emit_fmul_d(MachineCode, Int, Int, Int) -> Unit

fn emit_fsub_d(MachineCode, Int, Int, Int) -> Unit

fn emit_function(VCodeFunction) -> MachineCode

fn emit_ldr_d_imm(MachineCode, Int, Int, Int) -> Unit

fn emit_ldr_imm(MachineCode, Int, Int, Int) -> Unit

fn emit_ldr_w_imm(MachineCode, Int, Int, Int) -> Unit

fn emit_ldrb_imm(MachineCode, Int, Int, Int) -> Unit

fn emit_ldrh_imm(MachineCode, Int, Int, Int) -> Unit

fn emit_load_imm64(MachineCode, Int, Int64) -> Unit

fn emit_lsl_reg(MachineCode, Int, Int, Int) -> Unit

fn emit_lsr_reg(MachineCode, Int, Int, Int) -> Unit

fn emit_mov_reg(MachineCode, Int, Int) -> Unit

fn emit_movk(MachineCode, Int, Int, Int) -> Unit

fn emit_movz(MachineCode, Int, Int, Int) -> Unit

fn emit_mul(MachineCode, Int, Int, Int) -> Unit

fn emit_nop(MachineCode) -> Unit

fn emit_orr_reg(MachineCode, Int, Int, Int) -> Unit

fn emit_ret(MachineCode, Int) -> Unit

fn emit_sdiv(MachineCode, Int, Int, Int) -> Unit

fn emit_str_d_imm(MachineCode, Int, Int, Int) -> Unit

fn emit_str_imm(MachineCode, Int, Int, Int) -> Unit

fn emit_str_w_imm(MachineCode, Int, Int, Int) -> Unit

fn emit_strb_imm(MachineCode, Int, Int, Int) -> Unit

fn emit_strh_imm(MachineCode, Int, Int, Int) -> Unit

fn emit_sub_imm(MachineCode, Int, Int, Int) -> Unit

fn emit_sub_reg(MachineCode, Int, Int, Int) -> Unit

fn emit_udiv(MachineCode, Int, Int, Int) -> Unit

fn get_aarch64_rules() -> Array[RewriteRule]

fn get_optimization_rules() -> Array[RewriteRule]

fn lower_function(@ir.Function) -> VCodeFunction

fn lower_function_optimized(@ir.Function) -> VCodeFunction

fn lower_inst_with_patterns(LoweringContext, @ir.Inst, VCodeBlock, Array[RewriteRule]) -> Bool

fn match_pattern(Pattern, @ir.Inst, LoweringContext) -> MatchResult?

fn try_apply_rules(@ir.Inst, LoweringContext, Array[RewriteRule]) -> RewriteResult

// Errors

// Types and methods
pub(all) struct AArch64 {
  name : String
}
fn AArch64::new() -> Self
impl TargetISA for AArch64

pub enum AArch64Cond {
  Eq
  Ne
  Cs
  Cc
  Mi
  Pl
  Vs
  Vc
  Hi
  Ls
  Ge
  Lt
  Gt
  Le
  Al
  Nv
}

pub enum AArch64Extend {
  Uxtb
  Uxth
  Uxtw
  Uxtx
  Sxtb
  Sxth
  Sxtw
  Sxtx
}

pub enum AArch64Opcode {
  AddShifted(AArch64Shift, Int)
  SubShifted(AArch64Shift, Int)
  AddImm(Int64)
  SubImm(Int64)
  AndShifted(AArch64Shift, Int)
  OrrShifted(AArch64Shift, Int)
  EorShifted(AArch64Shift, Int)
  AndImm(Int64)
  OrrImm(Int64)
  EorImm(Int64)
  Madd
  Msub
  Mneg
  LdrOffset(Int)
  LdrPreIndex(Int)
  LdrPostIndex(Int)
  LdrRegister(AArch64Extend)
  StrOffset(Int)
  StrPreIndex(Int)
  StrPostIndex(Int)
  StrRegister(AArch64Extend)
  Cbz
  Cbnz
  Tbz(Int)
  Tbnz(Int)
  Csel(AArch64Cond)
  Csinc(AArch64Cond)
  Csneg(AArch64Cond)
  Csinv(AArch64Cond)
  Ubfx(Int, Int)
  Sbfx(Int, Int)
  Bfi(Int, Int)
  Bfxil(Int, Int)
  Movz(Int)
  Movn(Int)
  Movk(Int)
}

pub enum AArch64Pattern {
  AddWithShift(Int)
  AddWithExtend(AArch64Extend)
  MultiplyAdd
  MultiplySub
  MultiplyNeg
  ConditionalSelect(CmpKind)
  BitFieldExtract(Int, Int)
  CompareAndBranchZero
  TestBitAndBranch(Int)
}

pub(all) struct AArch64Regs {
  placeholder : Int
}
fn AArch64Regs::d0(Self) -> PReg
fn AArch64Regs::d1(Self) -> PReg
fn AArch64Regs::d2(Self) -> PReg
fn AArch64Regs::d3(Self) -> PReg
fn AArch64Regs::d4(Self) -> PReg
fn AArch64Regs::d5(Self) -> PReg
fn AArch64Regs::d6(Self) -> PReg
fn AArch64Regs::d7(Self) -> PReg
fn AArch64Regs::fp(Self) -> PReg
fn AArch64Regs::lr(Self) -> PReg
fn AArch64Regs::new() -> Self
fn AArch64Regs::x0(Self) -> PReg
fn AArch64Regs::x1(Self) -> PReg
fn AArch64Regs::x2(Self) -> PReg
fn AArch64Regs::x3(Self) -> PReg
fn AArch64Regs::x4(Self) -> PReg
fn AArch64Regs::x5(Self) -> PReg
fn AArch64Regs::x6(Self) -> PReg
fn AArch64Regs::x7(Self) -> PReg

pub enum AArch64RewriteResult {
  AddShifted(Int, Int, Int)
  SubShifted(Int, Int, Int)
  Madd(Int, Int, Int)
  Msub(Int, Int, Int)
  Mneg(Int, Int)
  LogicalShifted(VCodeOpcode, Int, Int, Int)
  NoMatch
}

pub enum AArch64Shift {
  Lsl
  Lsr
  Asr
  Ror
}

pub(all) struct AArch64StackFrame {
  frame : StackFrame
  use_fp : Bool
  mut lr_slot : Int?
  mut fp_slot : Int?
}
fn AArch64StackFrame::alloc_spill(Self, VReg) -> Int
fn AArch64StackFrame::finalize(Self) -> Unit
fn AArch64StackFrame::gen_epilogue(Self) -> Array[VCodeInst]
fn AArch64StackFrame::gen_prologue(Self) -> Array[VCodeInst]
fn AArch64StackFrame::new() -> Self
fn AArch64StackFrame::save_callee_reg(Self, PReg) -> Int
fn AArch64StackFrame::set_has_calls(Self) -> Unit
fn AArch64StackFrame::setup(Self) -> Unit
fn AArch64StackFrame::size(Self) -> Int
impl Show for AArch64StackFrame

pub enum CallConv {
  SystemV
  WindowsFastcall
  Aapcs64
  Wasm
}
impl Show for CallConv

pub enum CmpKind {
  Eq
  Ne
  Slt
  Sle
  Sgt
  Sge
  Ult
  Ule
  Ugt
  Uge
}
impl Show for CmpKind

pub(all) struct CodeCache {
  functions : Map[Int, CompiledFunction]
  mut total_size : Int
  max_size : Int
  mut hits : Int
  mut misses : Int
}
fn CodeCache::clear(Self) -> Unit
fn CodeCache::contains(Self, Int) -> Bool
fn CodeCache::get(Self, Int) -> CompiledFunction?
fn CodeCache::insert(Self, Int, CompiledFunction) -> Unit
fn CodeCache::invalidate(Self, Int) -> Unit
fn CodeCache::new(Int) -> Self
fn CodeCache::remove(Self, Int) -> Unit
fn CodeCache::stats(Self) -> (Int, Int, Int, Int)
impl Show for CodeCache

pub(all) struct CompiledFunction {
  name : String
  code : MachineCode
  entry_offset : Int
  code_size : Int
  frame_size : Int
  mut valid : Bool
}
fn CompiledFunction::get_code(Self) -> Array[Int]
fn CompiledFunction::invalidate(Self) -> Unit
fn CompiledFunction::is_valid(Self) -> Bool
fn CompiledFunction::new(String, MachineCode, Int) -> Self
impl Show for CompiledFunction

pub(all) struct ExecutableRegion {
  id : Int
  base_addr : Int
  size : Int
  mut write_pos : Int
  code : Array[Int]
  mut finalized : Bool
}
fn ExecutableRegion::address_at(Self, Int) -> Int
fn ExecutableRegion::finalize(Self) -> Unit
fn ExecutableRegion::new(Int, Int) -> Self
fn ExecutableRegion::read_at(Self, Int, Int) -> Array[Int]
fn ExecutableRegion::remaining(Self) -> Int
fn ExecutableRegion::write(Self, Array[Int]) -> Result[Int, String]
impl Show for ExecutableRegion

pub enum ExtendKind {
  Signed8To32
  Signed8To64
  Signed16To32
  Signed16To64
  Signed32To64
  Unsigned8To32
  Unsigned8To64
  Unsigned16To32
  Unsigned16To64
  Unsigned32To64
}
impl Show for ExtendKind

pub enum FCmpKind {
  Eq
  Ne
  Lt
  Le
  Gt
  Ge
}
impl Show for FCmpKind

pub(all) struct Fixup {
  offset : Int
  target_block : Int
  kind : FixupKind
}

pub enum FixupKind {
  Branch26
  Branch19
}

pub(all) struct JITRuntime {
  cache : CodeCache
  memory : MemoryManager
  mut compilations : Int
  mut recompilations : Int
}
fn JITRuntime::clear(Self) -> Unit
fn JITRuntime::invalidate(Self, Int) -> Unit
fn JITRuntime::lookup(Self, Int) -> CompiledFunction?
fn JITRuntime::new(Int, Int) -> Self
fn JITRuntime::register(Self, Int, CompiledFunction) -> Result[Int, String]
fn JITRuntime::stats(Self) -> (Int, Int, Int, Int, Int, Int, Int)
impl Show for JITRuntime

pub(all) struct LinearScanAllocator {
  int_regs : Array[PReg]
  float_regs : Array[PReg]
  mut active : Array[LiveInterval]
  mut next_spill_slot : Int
}
fn LinearScanAllocator::allocate(Self, VCodeFunction, LivenessResult) -> RegAllocResult
fn LinearScanAllocator::new(Array[PReg], Array[PReg]) -> Self

pub(all) struct LiveInterval {
  vreg : VReg
  start : ProgPoint
  mut end : ProgPoint
  uses : Array[ProgPoint]
  hint : PReg?
  mut assigned : PReg?
  mut spill_slot : Int?
}
impl Show for LiveInterval

pub(all) struct LivenessResult {
  intervals : Map[Int, LiveInterval]
  use_def : Map[Int, UseDefInfo]
  live_in : Array[@set.Set[Int]]
  live_out : Array[@set.Set[Int]]
}

pub(all) struct LoweringContext {
  ir_func : @ir.Function
  vcode_func : VCodeFunction
  value_map : Map[Int, VReg]
  block_map : Map[Int, Int]
}
fn LoweringContext::new(@ir.Function) -> Self

pub(all) struct MachineCode {
  bytes : Array[Int]
  mut pos : Int
  labels : Map[Int, Int]
  fixups : Array[Fixup]
}
fn MachineCode::add_fixup(Self, Int, FixupKind) -> Unit
fn MachineCode::align(Self, Int) -> Unit
fn MachineCode::align_block(Self) -> Unit
fn MachineCode::align_function(Self) -> Unit
fn MachineCode::current_pos(Self) -> Int
fn MachineCode::define_label(Self, Int) -> Unit
fn MachineCode::emit_byte(Self, Int) -> Unit
fn MachineCode::emit_inst(Self, Int, Int, Int, Int) -> Unit
fn MachineCode::get_bytes(Self) -> Array[Int]
fn MachineCode::hex_dump(Self) -> String
fn MachineCode::new() -> Self
fn MachineCode::resolve_fixups(Self) -> Unit
fn MachineCode::size(Self) -> Int

pub(all) struct MatchResult {
  values : Array[@ir.Value]
  int_consts : Array[Int64]
  float_consts : Array[Double]
  mut matched_inst : @ir.Inst?
}

pub enum MemType {
  I8
  I16
  I32
  I64
  F32
  F64
}
impl Show for MemType

pub(all) struct MemoryManager {
  regions : Array[ExecutableRegion]
  default_region_size : Int
  mut next_id : Int
  mut current_region : Int?
}
fn MemoryManager::alloc_region(Self, Int) -> ExecutableRegion
fn MemoryManager::finalize_all(Self) -> Unit
fn MemoryManager::get_current_region(Self) -> ExecutableRegion
fn MemoryManager::new(Int) -> Self
fn MemoryManager::total_allocated(Self) -> Int
fn MemoryManager::total_used(Self) -> Int
fn MemoryManager::write_code(Self, MachineCode) -> Result[(ExecutableRegion, Int), String]
impl Show for MemoryManager

pub(all) struct Operand {
  reg : VReg
  kind : OperandKind
  constraint : OperandConstraint
}

pub enum OperandConstraint {
  Any
  Fixed(PReg)
  Reuse(Int)
}

pub enum OperandKind {
  Use
  Def
  UseDef
}

pub(all) struct PReg {
  index : Int
  class : RegClass
}
impl Show for PReg

pub enum Pattern {
  Any
  ConstInt(Int64)
  ConstFloat(Double)
  AnyConstInt
  Inst(PatternOpcode, Array[Pattern])
  Lowered
}

pub enum PatternOpcode {
  Iadd
  Isub
  Imul
  Sdiv
  Udiv
  Band
  Bor
  Bxor
  Ishl
  Sshr
  Ushr
  Fadd
  Fsub
  Fmul
  Fdiv
  Iconst
  Fconst
  Icmp
  Fcmp
  Load
  Store
  Copy
  Select
}

pub(all) struct ProgPoint {
  block : Int
  inst : Int
  pos : ProgPos
}
impl Show for ProgPoint

pub enum ProgPos {
  Before
  After
}

pub enum Reg {
  Virtual(VReg)
  Physical(PReg)
}
impl Show for Reg

pub(all) struct RegAllocResult {
  assignments : Map[Int, PReg]
  spill_slots : Map[Int, Int]
  mut num_spill_slots : Int
  spills : Array[SpillInfo]
  reloads : Array[ReloadInfo]
}

pub enum RegClass {
  Int
  Float
}
impl Show for RegClass

pub(all) struct ReloadInfo {
  vreg : VReg
  slot : Int
  preg : PReg
  point : ProgPoint
}

pub enum RewriteResult {
  Rewritten(Array[VCodeInst])
  Identity(Int)
  Constant(Int64)
  ConstantFloat(Double)
  ShiftLeft(Int, Int)
  ShiftRight(Int, Int)
  NoMatch
}

pub(all) struct RewriteRule {
  name : String
  pattern : Pattern
  priority : Int
}

pub(all) struct SpillInfo {
  vreg : VReg
  slot : Int
  point : ProgPoint
}

pub(all) struct StackFrame {
  slots : Array[StackSlot]
  mut frame_size : Int
  frame_align : Int
  mut next_spill_offset : Int
  mut next_arg_offset : Int
  callee_saved_regs : Array[PReg]
  mut has_calls : Bool
}
fn StackFrame::add_callee_saved(Self, PReg) -> Int
fn StackFrame::alloc_local(Self, Int, Int, Int) -> Int
fn StackFrame::alloc_outgoing_arg(Self, Int, Int, Int) -> Int
fn StackFrame::alloc_spill_slot(Self, VReg, Int, Int) -> Int
fn StackFrame::finalize(Self) -> Unit
fn StackFrame::get_callee_saved(Self) -> Array[PReg]
fn StackFrame::new(Int) -> Self
fn StackFrame::print(Self) -> String
fn StackFrame::size(Self) -> Int
impl Show for StackFrame

pub enum StackOpcode {
  AdjustSP(Int)
  PushReg(PReg)
  PopReg(PReg)
}
impl Show for StackOpcode

pub(all) struct StackSlot {
  offset : Int
  size : Int
  align : Int
  kind : StackSlotKind
}
impl Show for StackSlot

pub enum StackSlotKind {
  Spill(VReg)
  Local(Int)
  OutgoingArg(Int)
  CalleeSaved(PReg)
  ReturnAddress
}
impl Show for StackSlotKind

pub(all) struct UseDefInfo {
  vreg : VReg
  mut def_point : ProgPoint?
  use_points : Array[ProgPoint]
}

pub(all) struct VCodeBlock {
  id : Int
  insts : Array[VCodeInst]
  params : Array[VReg]
  mut terminator : VCodeTerminator?
}
fn VCodeBlock::add_inst(Self, VCodeInst) -> Unit
fn VCodeBlock::new(Int) -> Self
fn VCodeBlock::set_terminator(Self, VCodeTerminator) -> Unit

pub(all) struct VCodeBuilder {
  func : VCodeFunction
  mut current_block : VCodeBlock?
}
fn VCodeBuilder::add(Self, VReg, VReg) -> VReg
fn VCodeBuilder::add_param(Self, RegClass) -> VReg
fn VCodeBuilder::add_result(Self, RegClass) -> Unit
fn VCodeBuilder::ashr(Self, VReg, VReg) -> VReg
fn VCodeBuilder::band(Self, VReg, VReg) -> VReg
fn VCodeBuilder::bor(Self, VReg, VReg) -> VReg
fn VCodeBuilder::branch(Self, VReg, VCodeBlock, VCodeBlock) -> Unit
fn VCodeBuilder::bxor(Self, VReg, VReg) -> VReg
fn VCodeBuilder::cmp(Self, CmpKind, VReg, VReg) -> VReg
fn VCodeBuilder::create_block(Self) -> VCodeBlock
fn VCodeBuilder::current_block(Self) -> VCodeBlock?
fn VCodeBuilder::fadd(Self, VReg, VReg) -> VReg
fn VCodeBuilder::fcmp(Self, FCmpKind, VReg, VReg) -> VReg
fn VCodeBuilder::fconst(Self, Double) -> VReg
fn VCodeBuilder::fdiv(Self, VReg, VReg) -> VReg
fn VCodeBuilder::fmul(Self, VReg, VReg) -> VReg
fn VCodeBuilder::fsub(Self, VReg, VReg) -> VReg
fn VCodeBuilder::get_function(Self) -> VCodeFunction
fn VCodeBuilder::iconst(Self, Int64) -> VReg
fn VCodeBuilder::jump(Self, VCodeBlock) -> Unit
fn VCodeBuilder::load(Self, MemType, VReg, Int) -> VReg
fn VCodeBuilder::lshr(Self, VReg, VReg) -> VReg
fn VCodeBuilder::mov(Self, VReg) -> VReg
fn VCodeBuilder::mul(Self, VReg, VReg) -> VReg
fn VCodeBuilder::new(String) -> Self
fn VCodeBuilder::print(Self) -> String
fn VCodeBuilder::return_(Self, Array[VReg]) -> Unit
fn VCodeBuilder::sdiv(Self, VReg, VReg) -> VReg
fn VCodeBuilder::shl(Self, VReg, VReg) -> VReg
fn VCodeBuilder::store(Self, MemType, VReg, VReg, Int) -> Unit
fn VCodeBuilder::sub(Self, VReg, VReg) -> VReg
fn VCodeBuilder::switch_to_block(Self, VCodeBlock) -> Unit
fn VCodeBuilder::trap(Self, String) -> Unit
fn VCodeBuilder::udiv(Self, VReg, VReg) -> VReg

pub(all) struct VCodeFunction {
  name : String
  params : Array[VReg]
  results : Array[RegClass]
  blocks : Array[VCodeBlock]
  mut next_vreg_id : Int
}
fn VCodeFunction::add_param(Self, RegClass) -> VReg
fn VCodeFunction::add_result(Self, RegClass) -> Unit
fn VCodeFunction::new(String) -> Self
fn VCodeFunction::new_block(Self) -> VCodeBlock
fn VCodeFunction::new_vreg(Self, RegClass) -> VReg
fn VCodeFunction::print(Self) -> String
impl Show for VCodeFunction

pub(all) struct VCodeInst {
  opcode : VCodeOpcode
  defs : Array[Writable]
  uses : Array[Reg]
}
fn VCodeInst::add_def(Self, Writable) -> Unit
fn VCodeInst::add_use(Self, Reg) -> Unit
fn VCodeInst::new(VCodeOpcode) -> Self
impl Show for VCodeInst

pub enum VCodeOpcode {
  Add
  Sub
  Mul
  SDiv
  UDiv
  And
  Or
  Xor
  Shl
  AShr
  LShr
  FAdd
  FSub
  FMul
  FDiv
  Load(MemType, Int)
  Store(MemType, Int)
  Move
  LoadConst(Int64)
  LoadConstF(Double)
  Cmp(CmpKind)
  FCmp(FCmpKind)
  Extend(ExtendKind)
  Truncate
  IntToFloat
  FloatToInt
  Nop
}
impl Show for VCodeOpcode

pub enum VCodeTerminator {
  Jump(Int)
  Branch(Reg, Int, Int)
  Return(Array[Reg])
  Trap(String)
}
impl Show for VCodeTerminator

pub(all) struct VReg {
  id : Int
  class : RegClass
}
impl Show for VReg

pub(all) struct Writable {
  reg : Reg
}
impl Show for Writable

// Type aliases

// Traits
pub(open) trait TargetISA {
  name(Self) -> String
  gpr_count(Self) -> Int
  fpr_count(Self) -> Int
  get_preg(Self, RegClass, Int) -> PReg?
  pointer_size(Self) -> Int
}

