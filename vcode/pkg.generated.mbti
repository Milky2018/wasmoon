// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/wasmoon/vcode"

import(
  "Milky2018/wasmoon/ir"
)

// Values
fn aapcs64_arg_fprs() -> Array[PReg]

fn aapcs64_arg_gprs() -> Array[PReg]

fn aapcs64_callee_saved() -> Array[PReg]

fn aapcs64_caller_saved() -> Array[PReg]

fn aapcs64_ret_fprs() -> Array[PReg]

fn aapcs64_ret_gprs() -> Array[PReg]

fn apply_aarch64_rule(String, MatchResult, @ir.Inst, LoweringContext) -> AArch64RewriteResult

fn get_aarch64_rules() -> Array[RewriteRule]

fn get_optimization_rules() -> Array[RewriteRule]

fn lower_function(@ir.Function) -> VCodeFunction

fn lower_function_optimized(@ir.Function) -> VCodeFunction

fn lower_inst_with_patterns(LoweringContext, @ir.Inst, VCodeBlock, Array[RewriteRule]) -> Bool

fn match_pattern(Pattern, @ir.Inst, LoweringContext) -> MatchResult?

fn try_apply_rules(@ir.Inst, LoweringContext, Array[RewriteRule]) -> RewriteResult

// Errors

// Types and methods
pub(all) struct AArch64 {
  name : String
}
fn AArch64::new() -> Self
impl TargetISA for AArch64

pub enum AArch64Cond {
  Eq
  Ne
  Cs
  Cc
  Mi
  Pl
  Vs
  Vc
  Hi
  Ls
  Ge
  Lt
  Gt
  Le
  Al
  Nv
}

pub enum AArch64Extend {
  Uxtb
  Uxth
  Uxtw
  Uxtx
  Sxtb
  Sxth
  Sxtw
  Sxtx
}

pub enum AArch64Opcode {
  AddShifted(AArch64Shift, Int)
  SubShifted(AArch64Shift, Int)
  AddImm(Int64)
  SubImm(Int64)
  AndShifted(AArch64Shift, Int)
  OrrShifted(AArch64Shift, Int)
  EorShifted(AArch64Shift, Int)
  AndImm(Int64)
  OrrImm(Int64)
  EorImm(Int64)
  Madd
  Msub
  Mneg
  LdrOffset(Int)
  LdrPreIndex(Int)
  LdrPostIndex(Int)
  LdrRegister(AArch64Extend)
  StrOffset(Int)
  StrPreIndex(Int)
  StrPostIndex(Int)
  StrRegister(AArch64Extend)
  Cbz
  Cbnz
  Tbz(Int)
  Tbnz(Int)
  Csel(AArch64Cond)
  Csinc(AArch64Cond)
  Csneg(AArch64Cond)
  Csinv(AArch64Cond)
  Ubfx(Int, Int)
  Sbfx(Int, Int)
  Bfi(Int, Int)
  Bfxil(Int, Int)
  Movz(Int)
  Movn(Int)
  Movk(Int)
}

pub enum AArch64Pattern {
  AddWithShift(Int)
  AddWithExtend(AArch64Extend)
  MultiplyAdd
  MultiplySub
  MultiplyNeg
  ConditionalSelect(CmpKind)
  BitFieldExtract(Int, Int)
  CompareAndBranchZero
  TestBitAndBranch(Int)
}

pub(all) struct AArch64Regs {
  placeholder : Int
}
fn AArch64Regs::d0(Self) -> PReg
fn AArch64Regs::d1(Self) -> PReg
fn AArch64Regs::d2(Self) -> PReg
fn AArch64Regs::d3(Self) -> PReg
fn AArch64Regs::d4(Self) -> PReg
fn AArch64Regs::d5(Self) -> PReg
fn AArch64Regs::d6(Self) -> PReg
fn AArch64Regs::d7(Self) -> PReg
fn AArch64Regs::fp(Self) -> PReg
fn AArch64Regs::lr(Self) -> PReg
fn AArch64Regs::new() -> Self
fn AArch64Regs::x0(Self) -> PReg
fn AArch64Regs::x1(Self) -> PReg
fn AArch64Regs::x2(Self) -> PReg
fn AArch64Regs::x3(Self) -> PReg
fn AArch64Regs::x4(Self) -> PReg
fn AArch64Regs::x5(Self) -> PReg
fn AArch64Regs::x6(Self) -> PReg
fn AArch64Regs::x7(Self) -> PReg

pub enum AArch64RewriteResult {
  AddShifted(Int, Int, Int)
  SubShifted(Int, Int, Int)
  Madd(Int, Int, Int)
  Msub(Int, Int, Int)
  Mneg(Int, Int)
  LogicalShifted(VCodeOpcode, Int, Int, Int)
  NoMatch
}

pub enum AArch64Shift {
  Lsl
  Lsr
  Asr
  Ror
}

pub enum CallConv {
  SystemV
  WindowsFastcall
  Aapcs64
  Wasm
}
impl Show for CallConv

pub enum CmpKind {
  Eq
  Ne
  Slt
  Sle
  Sgt
  Sge
  Ult
  Ule
  Ugt
  Uge
}
impl Show for CmpKind

pub enum ExtendKind {
  Signed8To32
  Signed8To64
  Signed16To32
  Signed16To64
  Signed32To64
  Unsigned8To32
  Unsigned8To64
  Unsigned16To32
  Unsigned16To64
  Unsigned32To64
}
impl Show for ExtendKind

pub enum FCmpKind {
  Eq
  Ne
  Lt
  Le
  Gt
  Ge
}
impl Show for FCmpKind

pub(all) struct LoweringContext {
  ir_func : @ir.Function
  vcode_func : VCodeFunction
  value_map : Map[Int, VReg]
  block_map : Map[Int, Int]
}
fn LoweringContext::new(@ir.Function) -> Self

pub(all) struct MatchResult {
  values : Array[@ir.Value]
  int_consts : Array[Int64]
  float_consts : Array[Double]
  mut matched_inst : @ir.Inst?
}

pub enum MemType {
  I8
  I16
  I32
  I64
  F32
  F64
}
impl Show for MemType

pub(all) struct Operand {
  reg : VReg
  kind : OperandKind
  constraint : OperandConstraint
}

pub enum OperandConstraint {
  Any
  Fixed(PReg)
  Reuse(Int)
}

pub enum OperandKind {
  Use
  Def
  UseDef
}

pub(all) struct PReg {
  index : Int
  class : RegClass
}
impl Show for PReg

pub enum Pattern {
  Any
  ConstInt(Int64)
  ConstFloat(Double)
  AnyConstInt
  Inst(PatternOpcode, Array[Pattern])
  Lowered
}

pub enum PatternOpcode {
  Iadd
  Isub
  Imul
  Sdiv
  Udiv
  Band
  Bor
  Bxor
  Ishl
  Sshr
  Ushr
  Fadd
  Fsub
  Fmul
  Fdiv
  Iconst
  Fconst
  Icmp
  Fcmp
  Load
  Store
  Copy
  Select
}

pub enum Reg {
  Virtual(VReg)
  Physical(PReg)
}
impl Show for Reg

pub enum RegClass {
  Int
  Float
}
impl Show for RegClass

pub enum RewriteResult {
  Rewritten(Array[VCodeInst])
  Identity(Int)
  Constant(Int64)
  ConstantFloat(Double)
  ShiftLeft(Int, Int)
  ShiftRight(Int, Int)
  NoMatch
}

pub(all) struct RewriteRule {
  name : String
  pattern : Pattern
  priority : Int
}

pub(all) struct VCodeBlock {
  id : Int
  insts : Array[VCodeInst]
  params : Array[VReg]
  mut terminator : VCodeTerminator?
}
fn VCodeBlock::add_inst(Self, VCodeInst) -> Unit
fn VCodeBlock::new(Int) -> Self
fn VCodeBlock::set_terminator(Self, VCodeTerminator) -> Unit

pub(all) struct VCodeBuilder {
  func : VCodeFunction
  mut current_block : VCodeBlock?
}
fn VCodeBuilder::add(Self, VReg, VReg) -> VReg
fn VCodeBuilder::add_param(Self, RegClass) -> VReg
fn VCodeBuilder::add_result(Self, RegClass) -> Unit
fn VCodeBuilder::ashr(Self, VReg, VReg) -> VReg
fn VCodeBuilder::band(Self, VReg, VReg) -> VReg
fn VCodeBuilder::bor(Self, VReg, VReg) -> VReg
fn VCodeBuilder::branch(Self, VReg, VCodeBlock, VCodeBlock) -> Unit
fn VCodeBuilder::bxor(Self, VReg, VReg) -> VReg
fn VCodeBuilder::cmp(Self, CmpKind, VReg, VReg) -> VReg
fn VCodeBuilder::create_block(Self) -> VCodeBlock
fn VCodeBuilder::current_block(Self) -> VCodeBlock?
fn VCodeBuilder::fadd(Self, VReg, VReg) -> VReg
fn VCodeBuilder::fcmp(Self, FCmpKind, VReg, VReg) -> VReg
fn VCodeBuilder::fconst(Self, Double) -> VReg
fn VCodeBuilder::fdiv(Self, VReg, VReg) -> VReg
fn VCodeBuilder::fmul(Self, VReg, VReg) -> VReg
fn VCodeBuilder::fsub(Self, VReg, VReg) -> VReg
fn VCodeBuilder::get_function(Self) -> VCodeFunction
fn VCodeBuilder::iconst(Self, Int64) -> VReg
fn VCodeBuilder::jump(Self, VCodeBlock) -> Unit
fn VCodeBuilder::load(Self, MemType, VReg, Int) -> VReg
fn VCodeBuilder::lshr(Self, VReg, VReg) -> VReg
fn VCodeBuilder::mov(Self, VReg) -> VReg
fn VCodeBuilder::mul(Self, VReg, VReg) -> VReg
fn VCodeBuilder::new(String) -> Self
fn VCodeBuilder::print(Self) -> String
fn VCodeBuilder::return_(Self, Array[VReg]) -> Unit
fn VCodeBuilder::sdiv(Self, VReg, VReg) -> VReg
fn VCodeBuilder::shl(Self, VReg, VReg) -> VReg
fn VCodeBuilder::store(Self, MemType, VReg, VReg, Int) -> Unit
fn VCodeBuilder::sub(Self, VReg, VReg) -> VReg
fn VCodeBuilder::switch_to_block(Self, VCodeBlock) -> Unit
fn VCodeBuilder::trap(Self, String) -> Unit
fn VCodeBuilder::udiv(Self, VReg, VReg) -> VReg

pub(all) struct VCodeFunction {
  name : String
  params : Array[VReg]
  results : Array[RegClass]
  blocks : Array[VCodeBlock]
  mut next_vreg_id : Int
}
fn VCodeFunction::add_param(Self, RegClass) -> VReg
fn VCodeFunction::add_result(Self, RegClass) -> Unit
fn VCodeFunction::new(String) -> Self
fn VCodeFunction::new_block(Self) -> VCodeBlock
fn VCodeFunction::new_vreg(Self, RegClass) -> VReg
fn VCodeFunction::print(Self) -> String
impl Show for VCodeFunction

pub(all) struct VCodeInst {
  opcode : VCodeOpcode
  defs : Array[Writable]
  uses : Array[Reg]
}
fn VCodeInst::add_def(Self, Writable) -> Unit
fn VCodeInst::add_use(Self, Reg) -> Unit
fn VCodeInst::new(VCodeOpcode) -> Self
impl Show for VCodeInst

pub enum VCodeOpcode {
  Add
  Sub
  Mul
  SDiv
  UDiv
  And
  Or
  Xor
  Shl
  AShr
  LShr
  FAdd
  FSub
  FMul
  FDiv
  Load(MemType, Int)
  Store(MemType, Int)
  Move
  LoadConst(Int64)
  LoadConstF(Double)
  Cmp(CmpKind)
  FCmp(FCmpKind)
  Extend(ExtendKind)
  Truncate
  IntToFloat
  FloatToInt
  Nop
}
impl Show for VCodeOpcode

pub enum VCodeTerminator {
  Jump(Int)
  Branch(Reg, Int, Int)
  Return(Array[Reg])
  Trap(String)
}
impl Show for VCodeTerminator

pub(all) struct VReg {
  id : Int
  class : RegClass
}
impl Show for VReg

pub(all) struct Writable {
  reg : Reg
}
impl Show for Writable

// Type aliases

// Traits
pub(open) trait TargetISA {
  name(Self) -> String
  gpr_count(Self) -> Int
  fpr_count(Self) -> Int
  get_preg(Self, RegClass, Int) -> PReg?
  pointer_size(Self) -> Int
}

