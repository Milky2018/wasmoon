// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/wasmoon/vcode/regalloc"

import(
  "Milky2018/wasmoon/ir"
  "Milky2018/wasmoon/vcode/abi"
  "Milky2018/wasmoon/vcode/block"
  "Milky2018/wasmoon/vcode/instr"
  "moonbitlang/core/set"
)

// Values
pub fn allocate_backtracking(VCodeFunction, LivenessResult, Array[@abi.PReg], Array[@abi.PReg], Array[@abi.PReg], Array[@abi.PReg]) -> RegAllocResult

pub fn allocate_registers_aarch64(VCodeFunction) -> VCodeFunction

pub fn allocate_registers_backtracking(VCodeFunction) -> VCodeFunction

pub fn apply_allocation(VCodeFunction, RegAllocResult) -> VCodeFunction

pub fn build_bundles_with_merging(VCodeFunction, LiveRangeSet) -> BundleSet

pub fn build_initial_bundles(LiveRangeSet) -> BundleSet

pub fn build_live_ranges(VCodeFunction, LivenessResult) -> LiveRangeSet

pub fn build_stack_layout_aarch64(RegAllocResult, VCodeFunction) -> AArch64StackFrame

pub fn compute_liveness(VCodeFunction) -> LivenessResult

pub fn compute_spill_weight(Bundle, LiveRangeSet, VCodeFunction) -> Double

pub fn debug_liveness(LivenessResult) -> String

pub fn eliminate_dead_code(VCodeFunction) -> VCodeFunction

pub fn process_constraints(VCodeFunction, RegAllocResult) -> Unit

// Errors

// Types and methods
pub(all) struct AArch64StackFrame {
  frame : StackFrame
  use_fp : Bool
  mut lr_slot : Int?
  mut fp_slot : Int?
}
pub fn AArch64StackFrame::alloc_spill(Self, @abi.VReg) -> Int
pub fn AArch64StackFrame::finalize(Self) -> Unit
pub fn AArch64StackFrame::gen_epilogue(Self) -> Array[@instr.VCodeInst]
pub fn AArch64StackFrame::gen_prologue(Self) -> Array[@instr.VCodeInst]
pub fn AArch64StackFrame::new() -> Self
pub fn AArch64StackFrame::save_callee_reg(Self, @abi.PReg) -> Int
pub fn AArch64StackFrame::set_has_calls(Self) -> Unit
pub fn AArch64StackFrame::setup(Self) -> Unit
pub fn AArch64StackFrame::size(Self) -> Int
pub impl Show for AArch64StackFrame

pub enum Allocation {
  Reg(@abi.PReg)
  Spill(Int)
  Unallocated
}
pub impl Show for Allocation

pub(all) struct BacktrackingAllocator {
  ranges : LiveRangeSet
  bundles : BundleSet
  int_reg_allocs : Map[Int, Array[ProgPointRange]]
  float_reg_allocs : Map[Int, Array[ProgPointRange]]
  mut queue : Array[QueueEntry]
  int_regs : Array[@abi.PReg]
  float_regs : Array[@abi.PReg]
  callee_saved_int : Array[@abi.PReg]
  callee_saved_float : Array[@abi.PReg]
  block_order : Map[Int, Int]
  func : VCodeFunction
}
pub fn BacktrackingAllocator::allocate(Self) -> Unit
pub fn BacktrackingAllocator::generate_result(Self) -> RegAllocResult
pub fn BacktrackingAllocator::new(VCodeFunction, LiveRangeSet, BundleSet, Array[@abi.PReg], Array[@abi.PReg], Array[@abi.PReg], Array[@abi.PReg]) -> Self

pub(all) struct Bundle {
  id : Int
  range_ids : Array[Int]
  mut spill_weight : Double
  mut spill_bundle_id : Int
  mut allocation : Allocation
  reg_class : @abi.RegClass
}
pub fn Bundle::contains_range(Self, Int) -> Bool
pub fn Bundle::crosses_call(Self, LiveRangeSet) -> Bool
pub fn Bundle::get_fixed_reg(Self, LiveRangeSet) -> @abi.PReg?
pub fn Bundle::has_fixed_constraint(Self, LiveRangeSet) -> Bool
pub fn Bundle::new(Int, @abi.RegClass) -> Self
pub fn Bundle::overlaps(Self, Self, LiveRangeSet) -> Bool
pub fn Bundle::total_length(Self, LiveRangeSet) -> Int

pub(all) struct BundleSet {
  bundles : Array[Bundle]
  spill_bundles : Array[SpillBundle]
  mut next_spill_slot : Int
}
pub fn BundleSet::get(Self, Int) -> Bundle
pub fn BundleSet::length(Self) -> Int
pub fn BundleSet::new() -> Self

pub(all) struct CoalescingInfo {
  forward_hints : Map[Int, Int]
  reverse_hints : Map[Int, Int]
}

pub(all) struct InstEdits {
  before : Array[RegMove]
  after : Array[RegMove]
}

pub(all) struct LinearScanAllocator {
  int_regs : Array[@abi.PReg]
  float_regs : Array[@abi.PReg]
  callee_saved_int_regs : Array[@abi.PReg]
  callee_saved_float_regs : Array[@abi.PReg]
  mut active : Array[LiveInterval]
  mut next_spill_slot : Int
  block_order : Map[Int, Int]
  reserved_int_regs : Map[(Int, Int), @set.Set[Int]]
  reserved_float_regs : Map[(Int, Int), @set.Set[Int]]
}
pub fn LinearScanAllocator::allocate(Self, VCodeFunction, LivenessResult) -> RegAllocResult
pub fn LinearScanAllocator::new(Array[@abi.PReg], Array[@abi.PReg], Array[@abi.PReg], callee_saved_float_regs? : Array[@abi.PReg]) -> Self

pub(all) struct LiveInterval {
  vreg : @abi.VReg
  start : ProgPoint
  mut end : ProgPoint
  uses : Array[ProgPoint]
  mut hint : @abi.PReg?
  mut hint_vreg : Int?
  mut assigned : @abi.PReg?
  mut spill_slot : Int?
  mut crosses_call : Bool
}
pub impl Show for LiveInterval

pub(all) struct LiveRange {
  id : Int
  vreg : @abi.VReg
  ranges : Array[ProgPointRange]
  uses : Array[UsePosition]
  mut bundle_id : Int
  mut allocation : Allocation
  mut crosses_call : Bool
}
pub fn LiveRange::end(Self, Map[Int, Int]) -> ProgPoint?
pub fn LiveRange::get_fixed_reg(Self) -> @abi.PReg?
pub fn LiveRange::has_fixed_constraint(Self) -> Bool
pub fn LiveRange::new(Int, @abi.VReg) -> Self
pub fn LiveRange::overlaps(Self, Self, Map[Int, Int]) -> Bool
pub fn LiveRange::start(Self, Map[Int, Int]) -> ProgPoint?
pub fn LiveRange::total_length(Self) -> Int
pub impl Show for LiveRange

pub(all) struct LiveRangeSet {
  ranges : Array[LiveRange]
  vreg_to_range : Map[Int, Int]
  block_order : Map[Int, Int]
}
pub fn LiveRangeSet::get(Self, Int) -> LiveRange
pub fn LiveRangeSet::get_by_vreg(Self, Int) -> LiveRange?
pub fn LiveRangeSet::length(Self) -> Int

pub(all) struct LivenessResult {
  intervals : Map[Int, LiveInterval]
  use_def : Map[Int, UseDefInfo]
  live_in : Array[@set.Set[Int]]
  live_out : Array[@set.Set[Int]]
  block_order : Map[Int, Int]
  call_points : Array[ProgPoint]
}

pub enum OperandConstraint {
  AnyReg
  FixedReg(@abi.PReg)
}
pub impl Show for OperandConstraint

pub(all) struct ProgPoint {
  block : Int
  inst : Int
  pos : ProgPos
}
pub impl Show for ProgPoint

pub(all) struct ProgPointRange {
  start : ProgPoint
  end : ProgPoint
}
pub impl Show for ProgPointRange

pub enum ProgPos {
  Before
  After
}

type QueueEntry
pub impl Eq for QueueEntry

pub(all) struct RegAllocResult {
  assignments : Map[Int, @abi.PReg]
  spill_slots : Map[Int, Int]
  mut num_spill_slots : Int
  spills : Array[SpillInfo]
  reloads : Array[ReloadInfo]
  inst_edits : Map[(Int, Int), InstEdits]
}

pub(all) struct RegMove {
  from : @abi.PReg
  to : @abi.PReg
  class : @abi.RegClass
}
pub impl Show for RegMove

pub(all) struct ReloadInfo {
  vreg : @abi.VReg
  slot : Int
  preg : @abi.PReg
  point : ProgPoint
}

pub(all) struct SpillBundle {
  id : Int
  slot : Int
  bundle_ids : Array[Int]
}
pub fn SpillBundle::new(Int, Int) -> Self

pub(all) struct SpillInfo {
  vreg : @abi.VReg
  slot : Int
  point : ProgPoint
}

pub(all) struct StackFrame {
  slots : Array[StackSlot]
  mut frame_size : Int
  frame_align : Int
  mut next_spill_offset : Int
  mut next_arg_offset : Int
  callee_saved_regs : Array[@abi.PReg]
  mut has_calls : Bool
}
pub fn StackFrame::add_callee_saved(Self, @abi.PReg) -> Int
pub fn StackFrame::alloc_local(Self, Int, Int, Int) -> Int
pub fn StackFrame::alloc_outgoing_arg(Self, Int, Int, Int) -> Int
pub fn StackFrame::alloc_spill_slot(Self, @abi.VReg, Int, Int) -> Int
pub fn StackFrame::finalize(Self) -> Unit
pub fn StackFrame::get_callee_saved(Self) -> Array[@abi.PReg]
pub fn StackFrame::new(Int) -> Self
pub fn StackFrame::print(Self) -> String
pub fn StackFrame::size(Self) -> Int
pub impl Show for StackFrame

pub(all) struct StackSlot {
  offset : Int
  size : Int
  align : Int
  kind : StackSlotKind
}
pub impl Show for StackSlot

pub enum StackSlotKind {
  Spill(@abi.VReg)
  Local(Int)
  OutgoingArg(Int)
  CalleeSaved(@abi.PReg)
}
pub impl Show for StackSlotKind

pub(all) struct UnionFind {
  parent : Array[Int]
  rank : Array[Int]
}
pub fn UnionFind::find(Self, Int) -> Int
pub fn UnionFind::get_all_sets(Self) -> Array[Array[Int]]
pub fn UnionFind::get_set(Self, Int) -> Array[Int]
pub fn UnionFind::length(Self) -> Int
pub fn UnionFind::new(Int) -> Self
pub fn UnionFind::num_sets(Self) -> Int
pub fn UnionFind::same_set(Self, Int, Int) -> Bool
pub fn UnionFind::union(Self, Int, Int) -> Bool

pub(all) struct UseDefInfo {
  vreg : @abi.VReg
  mut def_point : ProgPoint?
  use_points : Array[ProgPoint]
}

pub enum UseKind {
  Def
  Use
  DefUse
}
pub impl Show for UseKind

pub(all) struct UsePosition {
  point : ProgPoint
  kind : UseKind
  constraint : OperandConstraint
}
pub impl Show for UsePosition

pub(all) struct VCodeFunction {
  name : String
  params : Array[@abi.VReg]
  results : Array[@abi.RegClass]
  result_types : Array[@ir.Type]
  blocks : Array[@block.VCodeBlock]
  mut next_vreg_id : Int
  mut num_spill_slots : Int
  param_pregs : Array[@abi.PReg?]
  mut int_stack_params : Int
  mut max_outgoing_args_size : Int
}
pub fn VCodeFunction::add_param(Self, @abi.RegClass) -> @abi.VReg
pub fn VCodeFunction::add_param_preg(Self, @abi.PReg?) -> Unit
pub fn VCodeFunction::add_result(Self, @abi.RegClass) -> Unit
pub fn VCodeFunction::add_result_type(Self, @ir.Type) -> Unit
pub fn VCodeFunction::calls_multi_value_function(Self) -> Bool
pub fn VCodeFunction::clone_base(Self) -> Self
pub fn VCodeFunction::get_blocks(Self) -> Array[@block.VCodeBlock]
pub fn VCodeFunction::get_max_outgoing_args_size(Self) -> Int
pub fn VCodeFunction::get_name(Self) -> String
pub fn VCodeFunction::get_num_spill_slots(Self) -> Int
pub fn VCodeFunction::get_param_pregs(Self) -> Array[@abi.PReg?]
pub fn VCodeFunction::get_params(Self) -> Array[@abi.VReg]
pub fn VCodeFunction::get_result_types(Self) -> Array[@ir.Type]
pub fn VCodeFunction::needs_extra_results_ptr(Self) -> Bool
pub fn VCodeFunction::new(String) -> Self
pub fn VCodeFunction::new_block(Self) -> @block.VCodeBlock
pub fn VCodeFunction::new_vreg(Self, @abi.RegClass) -> @abi.VReg
pub fn VCodeFunction::print(Self) -> String
pub fn VCodeFunction::push_param(Self, @abi.VReg) -> Unit
pub fn VCodeFunction::set_int_stack_params(Self, Int) -> Unit
pub fn VCodeFunction::set_num_spill_slots(Self, Int) -> Unit
pub fn VCodeFunction::update_max_outgoing_args_size(Self, Int) -> Unit
pub impl Show for VCodeFunction

// Type aliases

// Traits

