// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/wasmoon/vcode/lower"

import(
  "Milky2018/wasmoon/ir"
  "Milky2018/wasmoon/vcode/abi"
  "Milky2018/wasmoon/vcode/block"
  "Milky2018/wasmoon/vcode/instr"
  "Milky2018/wasmoon/vcode/regalloc"
  "moonbitlang/core/hashset"
)

// Values
pub fn apply_aarch64_rule(String, MatchResult, @ir.Inst, LoweringContext) -> AArch64RewriteResult

pub fn get_aarch64_rules() -> Array[RewriteRule]

pub fn get_optimization_rules() -> Array[RewriteRule]

pub fn is_consecutive_ones(Int64) -> Bool

pub fn is_valid_add_imm(Int64) -> Bool

pub fn is_valid_logical_imm(Int64) -> Bool

pub fn lower_function(@ir.Function) -> @regalloc.VCodeFunction

pub fn lower_function_egraph(@ir.Function) -> @regalloc.VCodeFunction

pub fn lower_function_optimized(@ir.Function) -> @regalloc.VCodeFunction

pub fn lower_inst_with_patterns(LoweringContext, @ir.Inst, @block.VCodeBlock, Array[RewriteRule]) -> Bool

pub fn magic_s32(Int) -> MagicS32

pub fn magic_s64(Int64) -> MagicS64

pub fn magic_u32(UInt) -> MagicU32

pub fn magic_u64(UInt64) -> MagicU64

pub fn match_pattern(Pattern, @ir.Inst, LoweringContext) -> MatchResult?

pub fn optimize_vcode(@regalloc.VCodeFunction) -> Unit

pub fn try_apply_rules(@ir.Inst, LoweringContext, Array[RewriteRule]) -> RewriteResult

// Errors

// Types and methods
pub enum AArch64RewriteResult {
  AddShifted(Int, Int, Int)
  SubShifted(Int, Int, Int)
  Madd(Int, Int, Int)
  Msub(Int, Int, Int)
  Mneg(Int, Int)
  LogicalShifted(@instr.VCodeOpcode, Int, Int, Int)
  NoMatch
}

pub(all) struct LoweringContext {
  ir_func : @ir.Function
  vcode_func : @regalloc.VCodeFunction
  value_map : Map[Int, @abi.VReg]
  block_map : Map[Int, Int]
  stack_param_map : Map[Int, (Int, @abi.RegClass)]
  fused_icmps : @hashset.HashSet[Int]
}
pub fn LoweringContext::new(@ir.Function) -> Self

pub(all) struct MagicS32 {
  mul_by : Int
  shift_by : Int
}

pub(all) struct MagicS64 {
  mul_by : Int64
  shift_by : Int
}

pub(all) struct MagicU32 {
  mul_by : UInt
  do_add : Bool
  shift_by : Int
}

pub(all) struct MagicU64 {
  mul_by : UInt64
  do_add : Bool
  shift_by : Int
}

pub(all) struct MatchResult {
  values : Array[@ir.Value]
  int_consts : Array[Int64]
  float_consts : Array[Double]
  mut matched_inst : @ir.Inst?
}

pub enum Pattern {
  Any
  ConstInt(Int64)
  ConstFloat(Double)
  AnyConstInt
  Inst(PatternOpcode, Array[Pattern])
}

pub enum PatternOpcode {
  Iadd
  Isub
  Imul
  Sdiv
  Udiv
  Band
  Bor
  Bxor
  Ishl
  Sshr
  Ushr
  Fadd
  Fsub
  Fmul
  Fdiv
  Iconst
  Fconst
  Icmp
  Fcmp
  Copy
  Select
}

pub enum RewriteResult {
  Identity(Int)
  Constant(Int64)
  ShiftLeft(Int, Int)
  ShiftRight(Int, Int)
  NoMatch
}

pub(all) struct RewriteRule {
  name : String
  pattern : Pattern
  priority : Int
}

// Type aliases

// Traits

