// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/wasmoon/jit"

import(
  "Milky2018/wasmoon/cwasm"
  "Milky2018/wasmoon/vcode"
  "moonbitlang/core/hashset"
)

// Values
pub fn alloc_memory(Int64) -> Int64

pub fn check_trap() -> Unit raise JITTrap

pub fn free_memory(Int64) -> Unit

pub fn get_args_get_ptr() -> Int64

pub fn get_args_sizes_get_ptr() -> Int64

pub fn get_clock_time_get_ptr() -> Int64

pub fn get_environ_get_ptr() -> Int64

pub fn get_environ_sizes_get_ptr() -> Int64

pub fn get_fd_close_ptr() -> Int64

pub fn get_fd_fdstat_get_ptr() -> Int64

pub fn get_fd_prestat_get_ptr() -> Int64

pub fn get_fd_read_ptr() -> Int64

pub fn get_fd_write_ptr() -> Int64

pub fn get_proc_exit_ptr() -> Int64

pub fn get_random_get_ptr() -> Int64

pub fn get_spectest_print_f32_ptr() -> Int64

pub fn get_spectest_print_f64_f64_ptr() -> Int64

pub fn get_spectest_print_f64_ptr() -> Int64

pub fn get_spectest_print_i32_f32_ptr() -> Int64

pub fn get_spectest_print_i32_ptr() -> Int64

pub fn get_spectest_print_i64_ptr() -> Int64

pub fn get_spectest_print_ptr() -> Int64

pub fn get_temperature(Int, HotThreshold) -> FunctionTemperature

pub fn has_import_trampoline(String, String) -> Bool

pub fn memory_init(Int64, Int64, Bytes) -> Bool

// Errors
pub suberror JITTrap String

// Types and methods
pub(all) struct Breakpoint {
  id : Int
  func_idx : Int
  offset : Int
  mut enabled : Bool
  mut hit_count : Int
  condition : String?
}
pub fn Breakpoint::disable(Self) -> Unit
pub fn Breakpoint::enable(Self) -> Unit
pub fn Breakpoint::hit(Self) -> Unit
pub fn Breakpoint::new(Int, Int, Int) -> Self
pub fn Breakpoint::with_condition(Int, Int, Int, String) -> Self
pub impl Show for Breakpoint

pub(all) struct BreakpointManager {
  breakpoints : Map[Int, Breakpoint]
  by_location : Map[Int, Map[Int, Int]]
  mut next_id : Int
}
pub fn BreakpointManager::add(Self, Int, Int) -> Breakpoint
pub fn BreakpointManager::add_conditional(Self, Int, Int, String) -> Breakpoint
pub fn BreakpointManager::all(Self) -> Array[Breakpoint]
pub fn BreakpointManager::at_location(Self, Int, Int) -> Breakpoint?
pub fn BreakpointManager::clear(Self) -> Unit
pub fn BreakpointManager::count(Self) -> Int
pub fn BreakpointManager::get(Self, Int) -> Breakpoint?
pub fn BreakpointManager::new() -> Self
pub fn BreakpointManager::remove(Self, Int) -> Bool
pub fn BreakpointManager::should_break(Self, Int, Int) -> Bool

pub(all) struct CallCounter {
  counts : Map[Int, Int]
  mut total_calls : Int
}
pub fn CallCounter::clear(Self) -> Unit
pub fn CallCounter::get_count(Self, Int) -> Int
pub fn CallCounter::increment(Self, Int) -> Int
pub fn CallCounter::new() -> Self
pub fn CallCounter::reset(Self, Int) -> Unit
pub fn CallCounter::total(Self) -> Int
pub fn CallCounter::unique_functions(Self) -> Int

pub enum CompilationDecision {
  Interpret
  CompileAndExecute(CompilationMode)
  ExecuteCompiled
}
pub impl Show for CompilationDecision

pub(all) enum CompilationMode {
  Interpret
  Baseline
  Optimized
}
pub impl Show for CompilationMode

pub(all) struct CompilationQueue {
  requests : Array[CompilationRequest]
  max_size : Int
}
pub fn CompilationQueue::clear(Self) -> Unit
pub fn CompilationQueue::contains(Self, Int) -> Bool
pub fn CompilationQueue::dequeue(Self) -> CompilationRequest?
pub fn CompilationQueue::enqueue(Self, CompilationRequest) -> Bool
pub fn CompilationQueue::is_empty(Self) -> Bool
pub fn CompilationQueue::length(Self) -> Int
pub fn CompilationQueue::new(Int) -> Self

pub(all) struct CompilationRequest {
  func_idx : Int
  mode : CompilationMode
  priority : Int
}
pub fn CompilationRequest::new(Int, CompilationMode) -> Self
pub fn CompilationRequest::with_priority(Int, CompilationMode, Int) -> Self

pub enum CompilationStatus {
  NotCompiled
  Compiling
  Compiled
  Failed(String)
}
pub impl Show for CompilationStatus

pub(all) struct CompilationStrategy {
  profiler : Profiler
  queue : CompilationQueue
  config : TieredConfig
  mut decisions_interpret : Int
  mut decisions_compile : Int
  mut decisions_compiled : Int
}
pub fn CompilationStrategy::decide(Self, Int) -> CompilationDecision
pub fn CompilationStrategy::is_compiled(Self, Int) -> Bool
pub fn CompilationStrategy::mark_compiled(Self, Int) -> Unit
pub fn CompilationStrategy::new(TieredConfig) -> Self
pub fn CompilationStrategy::next_to_compile(Self) -> CompilationRequest?
pub fn CompilationStrategy::schedule_compilation(Self, Int, CompilationMode) -> Bool
pub fn CompilationStrategy::stats(Self) -> (Int, Int, Int, Int, Int, Int)
pub impl Show for CompilationStrategy

pub(all) struct DebugContext {
  source_map : SourceMap
  breakpoints : BreakpointManager
  mut enabled : Bool
  mut step_mode : StepMode
  mut current_trace : StackTrace?
}
pub fn DebugContext::disable(Self) -> Unit
pub fn DebugContext::enable(Self) -> Unit
pub fn DebugContext::location_string(Self, Int, Int) -> String
pub fn DebugContext::new() -> Self
pub fn DebugContext::on_pause(Self, Int, Int) -> Unit
pub fn DebugContext::set_step_mode(Self, StepMode) -> Unit
pub fn DebugContext::should_pause(Self, Int, Int) -> Bool
pub impl Show for DebugContext

pub(all) struct ExecCode {
  ptr : Int64
  size : Int
}
pub fn ExecCode::call_i64_i64(Self, Int64) -> Int64
pub fn ExecCode::call_i64_void(Self, Int64) -> Unit
pub fn ExecCode::call_i64i64_i64(Self, Int64, Int64) -> Int64
pub fn ExecCode::call_i64i64_void(Self, Int64, Int64) -> Unit
pub fn ExecCode::call_i64i64i64_i64(Self, Int64, Int64, Int64) -> Int64
pub fn ExecCode::call_i64i64i64_void(Self, Int64, Int64, Int64) -> Unit
pub fn ExecCode::call_i64i64i64i64_i64(Self, Int64, Int64, Int64, Int64) -> Int64
pub fn ExecCode::call_i64i64i64i64_void(Self, Int64, Int64, Int64, Int64) -> Unit
pub fn ExecCode::call_void_i64(Self) -> Int64
pub fn ExecCode::call_void_void(Self) -> Unit
pub fn ExecCode::debug_print(Self) -> Unit
pub fn ExecCode::free(Self) -> Unit
pub fn ExecCode::from_bytes(Bytes) -> Self?
pub fn ExecCode::new(Array[Int]) -> Self?

pub(all) struct FunctionEntry {
  func_idx : Int
  mut status : CompilationStatus
  mut compiled_code : @vcode.CompiledFunction?
  mut call_count : Int
}
pub fn FunctionEntry::is_compiled(Self) -> Bool
pub fn FunctionEntry::new(Int) -> Self

pub enum FunctionTemperature {
  Cold
  Warm
  Hot
}
pub impl Show for FunctionTemperature

pub(all) struct HotThreshold {
  warm_threshold : Int
  hot_threshold : Int
}
pub fn HotThreshold::aggressive() -> Self
pub fn HotThreshold::conservative() -> Self
pub fn HotThreshold::default() -> Self

pub(all) struct JITContext {
  ctx_ptr : Int64
  func_table_ptr : Int64
}
pub fn JITContext::activate(Self) -> Unit
pub fn JITContext::call_i64_f32(Self, Int64, Int64) -> Float raise JITTrap
pub fn JITContext::call_i64_f64(Self, Int64, Int64) -> Double raise JITTrap
pub fn JITContext::call_i64_i64(Self, Int64, Int64) -> Int64 raise JITTrap
pub fn JITContext::call_i64_void(Self, Int64, Int64) -> Unit raise JITTrap
pub fn JITContext::call_i64i64_f32(Self, Int64, Int64, Int64) -> Float raise JITTrap
pub fn JITContext::call_i64i64_f64(Self, Int64, Int64, Int64) -> Double raise JITTrap
pub fn JITContext::call_i64i64_i64(Self, Int64, Int64, Int64) -> Int64 raise JITTrap
pub fn JITContext::call_i64i64_void(Self, Int64, Int64, Int64) -> Unit raise JITTrap
pub fn JITContext::call_void_f32(Self, Int64) -> Float raise JITTrap
pub fn JITContext::call_void_f64(Self, Int64) -> Double raise JITTrap
pub fn JITContext::call_void_i64(Self, Int64) -> Int64 raise JITTrap
pub fn JITContext::call_void_void(Self, Int64) -> Unit raise JITTrap
pub fn JITContext::free(Self) -> Unit
pub fn JITContext::new(Int) -> Self?
pub fn JITContext::set_func(Self, Int, Int64) -> Unit
pub fn JITContext::set_memory(Self, Int64, Int64) -> Unit

pub(all) struct JITEngine {
  strategy : CompilationStrategy
  runtime : @vcode.JITRuntime
  functions : Map[Int, FunctionEntry]
  mut total_calls : Int
  mut jit_calls : Int
  mut interpreter_calls : Int
  mut compilation_failures : Int
}
pub fn JITEngine::default() -> Self
pub fn JITEngine::get_compiled(Self, Int) -> @vcode.CompiledFunction?
pub fn JITEngine::invalidate(Self, Int) -> Unit
pub fn JITEngine::is_compiled(Self, Int) -> Bool
pub fn JITEngine::mark_compiled(Self, Int, @vcode.CompiledFunction) -> Unit
pub fn JITEngine::mark_failed(Self, Int, String) -> Unit
pub fn JITEngine::new(TieredConfig) -> Self
pub fn JITEngine::on_call(Self, Int) -> Bool
pub fn JITEngine::stats(Self) -> (Int, Int, Int, Int, Int)
pub impl Show for JITEngine

pub(all) struct JITFunction {
  name : String
  func_idx : Int
  exec_code : ExecCode
  frame_size : Int
  num_params : Int
  has_result : Bool
}
pub fn JITFunction::call(Self, Array[Int64]) -> Int64?
pub fn JITFunction::debug_print(Self) -> Unit
pub fn JITFunction::free(Self) -> Unit
pub fn JITFunction::new(String, Int, ExecCode, Int, Int, Bool) -> Self

pub(all) struct JITModule {
  functions : Map[Int, JITFunction]
  by_name : Map[String, Int]
  mut context : JITContext?
  mut num_imports : Int
}
pub fn JITModule::call_with_context(Self, JITFunction, Array[Int64]) -> Int64? raise JITTrap
pub fn JITModule::free(Self) -> Unit
pub fn JITModule::get_func(Self, Int) -> JITFunction?
pub fn JITModule::get_func_by_name(Self, String) -> JITFunction?
pub fn JITModule::load(@cwasm.PrecompiledModule, Array[(Int, Bool)]) -> Self?
pub fn JITModule::new() -> Self

pub(all) struct Profiler {
  counter : CallCounter
  threshold : HotThreshold
  hot_functions : @hashset.HashSet[Int]
  pending_compilation : @hashset.HashSet[Int]
  compiled_functions : @hashset.HashSet[Int]
}
pub fn Profiler::get_function_temperature(Self, Int) -> FunctionTemperature
pub fn Profiler::get_pending(Self) -> Array[Int]
pub fn Profiler::is_compiled(Self, Int) -> Bool
pub fn Profiler::mark_compiled(Self, Int) -> Unit
pub fn Profiler::new(HotThreshold) -> Self
pub fn Profiler::record_call(Self, Int) -> (Int, Bool)
pub fn Profiler::should_use_jit(Self, Int) -> Bool
pub fn Profiler::stats(Self) -> (Int, Int, Int, Int)
pub impl Show for Profiler

pub(all) struct SourceLocation {
  func_idx : Int
  offset : Int
  file : String?
  line : Int?
  column : Int?
}
pub fn SourceLocation::new(Int, Int) -> Self
pub fn SourceLocation::with_source(Int, Int, String, Int, Int) -> Self
pub impl Show for SourceLocation

pub(all) struct SourceMap {
  mappings : Map[Int, Map[Int, SourceLocation]]
  func_names : Map[Int, String]
}
pub fn SourceMap::add_func_name(Self, Int, String) -> Unit
pub fn SourceMap::add_mapping(Self, Int, Int, SourceLocation) -> Unit
pub fn SourceMap::find_nearest(Self, Int, Int) -> SourceLocation?
pub fn SourceMap::get_func_name(Self, Int) -> String
pub fn SourceMap::get_location(Self, Int, Int) -> SourceLocation?
pub fn SourceMap::mapping_count(Self) -> Int
pub fn SourceMap::new() -> Self

pub(all) struct StackFrame {
  index : Int
  func_idx : Int
  ip : Int
  func_name : String
  location : SourceLocation?
  local_count : Int
}
pub fn StackFrame::new(Int, Int, Int, String) -> Self
pub fn StackFrame::with_location(Int, Int, Int, String, SourceLocation) -> Self
pub impl Show for StackFrame

pub(all) struct StackTrace {
  frames : Array[StackFrame]
  error : String?
}
pub fn StackTrace::depth(Self) -> Int
pub fn StackTrace::new() -> Self
pub fn StackTrace::push_frame(Self, StackFrame) -> Unit
pub fn StackTrace::with_error(String) -> Self
pub impl Show for StackTrace

pub enum StepMode {
  Continue
  StepInto
  StepOver
  StepOut
}
pub impl Show for StepMode

pub(all) struct TieredConfig {
  baseline_threshold : Int
  optimize_threshold : Int
  synchronous : Bool
  max_concurrent : Int
}
pub fn TieredConfig::default() -> Self
pub fn TieredConfig::deferred() -> Self
pub fn TieredConfig::eager() -> Self

// Type aliases

// Traits

