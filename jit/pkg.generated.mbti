// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/wasmoon/jit"

import(
  "Milky2018/wasmoon/cwasm"
  "Milky2018/wasmoon/jit/jit_ffi"
  "Milky2018/wasmoon/types"
  "Milky2018/wasmoon/vcode"
  "moonbitlang/core/hashset"
)

// Values
pub fn alloc_memory(Int64) -> Int64

pub fn c_jit_read_i64(Int64) -> Int64

pub fn c_jit_write_i64(Int64, Int64) -> Unit

pub fn check_trap() -> Unit raise JITTrap

pub fn free_memory(Int64) -> Unit

pub fn get_args_get_ptr() -> Int64

pub fn get_args_sizes_get_ptr() -> Int64

pub fn get_clock_time_get_ptr() -> Int64

pub fn get_current_memory_base() -> Int64

pub fn get_environ_get_ptr() -> Int64

pub fn get_environ_sizes_get_ptr() -> Int64

pub fn get_fd_close_ptr() -> Int64

pub fn get_fd_fdstat_get_ptr() -> Int64

pub fn get_fd_prestat_get_ptr() -> Int64

pub fn get_fd_read_ptr() -> Int64

pub fn get_fd_write_ptr() -> Int64

pub fn get_memory_base_ptr() -> Int64

pub fn get_memory_grow_ptr() -> Int64

pub fn get_memory_size_bytes_ptr() -> Int64

pub fn get_memory_size_ptr() -> Int64

pub fn get_proc_exit_ptr() -> Int64

pub fn get_random_get_ptr() -> Int64

pub fn get_spectest_print_f32_ptr() -> Int64

pub fn get_spectest_print_f64_f64_ptr() -> Int64

pub fn get_spectest_print_f64_ptr() -> Int64

pub fn get_spectest_print_i32_f32_ptr() -> Int64

pub fn get_spectest_print_i32_ptr() -> Int64

pub fn get_spectest_print_i64_ptr() -> Int64

pub fn get_spectest_print_ptr() -> Int64

pub fn get_temperature(Int, HotThreshold) -> FunctionTemperature

pub fn has_import_trampoline(String, String) -> Bool

pub fn is_jit_supported_module(String) -> Bool

pub fn memory_init(Int64, Int64, Bytes) -> Bool

// Errors
pub suberror JITTrap String
pub impl Show for JITTrap

pub suberror PolycallError {
  InputNumber(Int, Int)
  OutputNumber(Int, Int)
  JIT(JITTrap)
}

// Types and methods
pub(all) struct Breakpoint {
  id : Int
  func_idx : Int
  offset : Int
  mut enabled : Bool
  mut hit_count : Int
  condition : String?
}
pub fn Breakpoint::disable(Self) -> Unit
pub fn Breakpoint::enable(Self) -> Unit
pub fn Breakpoint::hit(Self) -> Unit
pub fn Breakpoint::new(Int, Int, Int) -> Self
pub fn Breakpoint::with_condition(Int, Int, Int, String) -> Self
pub impl Show for Breakpoint

pub(all) struct BreakpointManager {
  breakpoints : Map[Int, Breakpoint]
  by_location : Map[Int, Map[Int, Int]]
  mut next_id : Int
}
pub fn BreakpointManager::add(Self, Int, Int) -> Breakpoint
pub fn BreakpointManager::add_conditional(Self, Int, Int, String) -> Breakpoint
pub fn BreakpointManager::all(Self) -> Array[Breakpoint]
pub fn BreakpointManager::at_location(Self, Int, Int) -> Breakpoint?
pub fn BreakpointManager::clear(Self) -> Unit
pub fn BreakpointManager::count(Self) -> Int
pub fn BreakpointManager::get(Self, Int) -> Breakpoint?
pub fn BreakpointManager::new() -> Self
pub fn BreakpointManager::remove(Self, Int) -> Bool
pub fn BreakpointManager::should_break(Self, Int, Int) -> Bool

pub(all) struct CallCounter {
  counts : Map[Int, Int]
  mut total_calls : Int
}
pub fn CallCounter::clear(Self) -> Unit
pub fn CallCounter::get_count(Self, Int) -> Int
pub fn CallCounter::increment(Self, Int) -> Int
pub fn CallCounter::new() -> Self
pub fn CallCounter::reset(Self, Int) -> Unit
pub fn CallCounter::total(Self) -> Int
pub fn CallCounter::unique_functions(Self) -> Int

pub enum CompilationDecision {
  Interpret
  CompileAndExecute(CompilationMode)
  ExecuteCompiled
}
pub impl Show for CompilationDecision

pub(all) enum CompilationMode {
  Interpret
  Baseline
  Optimized
}
pub impl Show for CompilationMode

pub(all) struct CompilationQueue {
  requests : Array[CompilationRequest]
  max_size : Int
}
pub fn CompilationQueue::clear(Self) -> Unit
pub fn CompilationQueue::contains(Self, Int) -> Bool
pub fn CompilationQueue::dequeue(Self) -> CompilationRequest?
pub fn CompilationQueue::enqueue(Self, CompilationRequest) -> Bool
pub fn CompilationQueue::is_empty(Self) -> Bool
pub fn CompilationQueue::length(Self) -> Int
pub fn CompilationQueue::new(Int) -> Self

pub(all) struct CompilationRequest {
  func_idx : Int
  mode : CompilationMode
  priority : Int
}
pub fn CompilationRequest::new(Int, CompilationMode) -> Self
pub fn CompilationRequest::with_priority(Int, CompilationMode, Int) -> Self

pub enum CompilationStatus {
  NotCompiled
  Compiling
  Compiled
  Failed(String)
}
pub impl Show for CompilationStatus

pub(all) struct CompilationStrategy {
  profiler : Profiler
  queue : CompilationQueue
  config : TieredConfig
  mut decisions_interpret : Int
  mut decisions_compile : Int
  mut decisions_compiled : Int
}
pub fn CompilationStrategy::decide(Self, Int) -> CompilationDecision
pub fn CompilationStrategy::is_compiled(Self, Int) -> Bool
pub fn CompilationStrategy::mark_compiled(Self, Int) -> Unit
pub fn CompilationStrategy::new(TieredConfig) -> Self
pub fn CompilationStrategy::next_to_compile(Self) -> CompilationRequest?
pub fn CompilationStrategy::schedule_compilation(Self, Int, CompilationMode) -> Bool
pub fn CompilationStrategy::stats(Self) -> (Int, Int, Int, Int, Int, Int)
pub impl Show for CompilationStrategy

pub(all) struct DebugContext {
  source_map : SourceMap
  breakpoints : BreakpointManager
  mut enabled : Bool
  mut step_mode : StepMode
  mut current_trace : StackTrace?
}
pub fn DebugContext::disable(Self) -> Unit
pub fn DebugContext::enable(Self) -> Unit
pub fn DebugContext::location_string(Self, Int, Int) -> String
pub fn DebugContext::new() -> Self
pub fn DebugContext::on_pause(Self, Int, Int) -> Unit
pub fn DebugContext::set_step_mode(Self, StepMode) -> Unit
pub fn DebugContext::should_pause(Self, Int, Int) -> Bool
pub impl Show for DebugContext

pub struct ExecCode(@jit_ffi.ExecCode)
#deprecated
pub fn ExecCode::inner(Self) -> @jit_ffi.ExecCode
pub fn ExecCode::new(Array[Int]) -> Self?
pub fn ExecCode::ptr(Self) -> Int64

pub(all) struct FunctionEntry {
  func_idx : Int
  mut status : CompilationStatus
  mut compiled_code : @vcode.CompiledFunction?
  mut call_count : Int
}
pub fn FunctionEntry::is_compiled(Self) -> Bool
pub fn FunctionEntry::new(Int) -> Self

pub enum FunctionTemperature {
  Cold
  Warm
  Hot
}
pub impl Show for FunctionTemperature

pub(all) struct HotThreshold {
  warm_threshold : Int
  hot_threshold : Int
}
pub fn HotThreshold::aggressive() -> Self
pub fn HotThreshold::conservative() -> Self
pub fn HotThreshold::default() -> Self

pub(all) struct JITEngine {
  strategy : CompilationStrategy
  runtime : @vcode.JITRuntime
  functions : Map[Int, FunctionEntry]
  mut total_calls : Int
  mut jit_calls : Int
  mut interpreter_calls : Int
  mut compilation_failures : Int
}
pub fn JITEngine::default() -> Self
pub fn JITEngine::get_compiled(Self, Int) -> @vcode.CompiledFunction?
pub fn JITEngine::invalidate(Self, Int) -> Unit
pub fn JITEngine::is_compiled(Self, Int) -> Bool
pub fn JITEngine::mark_compiled(Self, Int, @vcode.CompiledFunction) -> Unit
pub fn JITEngine::mark_failed(Self, Int, String) -> Unit
pub fn JITEngine::new(TieredConfig) -> Self
pub fn JITEngine::on_call(Self, Int) -> Bool
pub fn JITEngine::stats(Self) -> (Int, Int, Int, Int, Int)
pub impl Show for JITEngine

pub struct JITFunction {
  name : String
  param_types : Array[@types.ValueType]
  result_types : Array[@types.ValueType]
  // private fields
}

type JITModule
pub fn JITModule::call_with_context(Self, JITFunction, Array[Int64]) -> Array[Int64] raise JITTrap
pub fn[Arg : DynamicArgs, Ret : DynamicReturn] JITModule::call_with_context_poly(Self, JITFunction, Arg) -> Ret raise PolycallError
pub fn JITModule::from_single_function(Array[Int], String, Array[@types.ValueType], Array[@types.ValueType], Int64) -> Self?
pub fn JITModule::get_func(Self, Int) -> JITFunction?
pub fn JITModule::get_func_by_name(Self, String) -> JITFunction?
pub fn JITModule::get_func_ptr(Self, Int) -> Int64
pub fn JITModule::init_indirect_table(Self, Int, Array[(Int, Int, Int)]) -> Unit
pub fn JITModule::init_shared_tables(Self, Array[JITTable?], Array[(Int, Int, Int, Int)]) -> Unit
pub fn JITModule::load(@cwasm.PrecompiledModule, Array[(Array[@types.ValueType], Array[@types.ValueType])]) -> Self?
pub fn JITModule::new() -> Self
pub fn JITModule::set_globals(Self, Int64) -> Unit
pub fn JITModule::set_memory(Self, Int64, Int64) -> Unit

type JITTable
pub fn JITTable::get_max(Self) -> Int?
pub fn JITTable::get_size(Self) -> Int
pub fn JITTable::new(Int, Int?) -> Self?
pub fn JITTable::set(Self, Int, Int64, Int) -> Unit
pub impl Show for JITTable

pub(all) struct Profiler {
  counter : CallCounter
  threshold : HotThreshold
  hot_functions : @hashset.HashSet[Int]
  pending_compilation : @hashset.HashSet[Int]
  compiled_functions : @hashset.HashSet[Int]
}
pub fn Profiler::get_function_temperature(Self, Int) -> FunctionTemperature
pub fn Profiler::get_pending(Self) -> Array[Int]
pub fn Profiler::is_compiled(Self, Int) -> Bool
pub fn Profiler::mark_compiled(Self, Int) -> Unit
pub fn Profiler::new(HotThreshold) -> Self
pub fn Profiler::record_call(Self, Int) -> (Int, Bool)
pub fn Profiler::should_use_jit(Self, Int) -> Bool
pub fn Profiler::stats(Self) -> (Int, Int, Int, Int)
pub impl Show for Profiler

pub(all) struct Single[A](A)
#deprecated
pub fn[A] Single::inner(Self[A]) -> A
pub impl[A : @types.ToInt64] DynamicArgs for Single[A]
pub impl[A : @types.FromInt64] DynamicReturn for Single[A]

pub(all) struct SourceLocation {
  func_idx : Int
  offset : Int
  file : String?
  line : Int?
  column : Int?
}
pub fn SourceLocation::new(Int, Int) -> Self
pub fn SourceLocation::with_source(Int, Int, String, Int, Int) -> Self
pub impl Show for SourceLocation

pub(all) struct SourceMap {
  mappings : Map[Int, Map[Int, SourceLocation]]
  func_names : Map[Int, String]
}
pub fn SourceMap::add_func_name(Self, Int, String) -> Unit
pub fn SourceMap::add_mapping(Self, Int, Int, SourceLocation) -> Unit
pub fn SourceMap::find_nearest(Self, Int, Int) -> SourceLocation?
pub fn SourceMap::get_func_name(Self, Int) -> String
pub fn SourceMap::get_location(Self, Int, Int) -> SourceLocation?
pub fn SourceMap::mapping_count(Self) -> Int
pub fn SourceMap::new() -> Self

pub(all) struct StackFrame {
  index : Int
  func_idx : Int
  ip : Int
  func_name : String
  location : SourceLocation?
  local_count : Int
}
pub fn StackFrame::new(Int, Int, Int, String) -> Self
pub fn StackFrame::with_location(Int, Int, Int, String, SourceLocation) -> Self
pub impl Show for StackFrame

pub(all) struct StackTrace {
  frames : Array[StackFrame]
  error : String?
}
pub fn StackTrace::depth(Self) -> Int
pub fn StackTrace::new() -> Self
pub fn StackTrace::push_frame(Self, StackFrame) -> Unit
pub fn StackTrace::with_error(String) -> Self
pub impl Show for StackTrace

pub enum StepMode {
  Continue
  StepInto
  StepOver
  StepOut
}
pub impl Show for StepMode

pub(all) struct TieredConfig {
  baseline_threshold : Int
  optimize_threshold : Int
  synchronous : Bool
  max_concurrent : Int
}
pub fn TieredConfig::default() -> Self
pub fn TieredConfig::deferred() -> Self
pub fn TieredConfig::eager() -> Self

// Type aliases

// Traits
pub trait DynamicArgs {
  to_int64_array(Self) -> Array[Int64]
}
pub impl DynamicArgs for Unit
pub impl[A : @types.ToInt64, B : @types.ToInt64] DynamicArgs for (A, B)
pub impl[A : @types.ToInt64, B : @types.ToInt64, C : @types.ToInt64] DynamicArgs for (A, B, C)
pub impl[A : @types.ToInt64, B : @types.ToInt64, C : @types.ToInt64, D : @types.ToInt64] DynamicArgs for (A, B, C, D)

pub trait DynamicReturn {
  from_int64_array(Array[Int64]) -> Self
}
pub impl DynamicReturn for Unit
pub impl[A : @types.FromInt64, B : @types.FromInt64] DynamicReturn for (A, B)
pub impl[A : @types.FromInt64, B : @types.FromInt64, C : @types.FromInt64] DynamicReturn for (A, B, C)
pub impl[A : @types.FromInt64, B : @types.FromInt64, C : @types.FromInt64, D : @types.FromInt64] DynamicReturn for (A, B, C, D)

