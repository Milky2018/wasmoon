// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/wasmoon/jit"

import(
  "Milky2018/wasmoon/vcode"
  "moonbitlang/core/hashset"
)

// Values
fn get_temperature(Int, HotThreshold) -> FunctionTemperature

// Errors

// Types and methods
pub(all) struct Breakpoint {
  id : Int
  func_idx : Int
  offset : Int
  mut enabled : Bool
  mut hit_count : Int
  condition : String?
}
fn Breakpoint::disable(Self) -> Unit
fn Breakpoint::enable(Self) -> Unit
fn Breakpoint::hit(Self) -> Unit
fn Breakpoint::new(Int, Int, Int) -> Self
fn Breakpoint::with_condition(Int, Int, Int, String) -> Self
impl Show for Breakpoint

pub(all) struct BreakpointManager {
  breakpoints : Map[Int, Breakpoint]
  by_location : Map[Int, Map[Int, Int]]
  mut next_id : Int
}
fn BreakpointManager::add(Self, Int, Int) -> Breakpoint
fn BreakpointManager::add_conditional(Self, Int, Int, String) -> Breakpoint
fn BreakpointManager::all(Self) -> Array[Breakpoint]
fn BreakpointManager::at_location(Self, Int, Int) -> Breakpoint?
fn BreakpointManager::clear(Self) -> Unit
fn BreakpointManager::count(Self) -> Int
fn BreakpointManager::get(Self, Int) -> Breakpoint?
fn BreakpointManager::new() -> Self
fn BreakpointManager::remove(Self, Int) -> Bool
fn BreakpointManager::should_break(Self, Int, Int) -> Bool

pub(all) struct CallCounter {
  counts : Map[Int, Int]
  mut total_calls : Int
}
fn CallCounter::clear(Self) -> Unit
fn CallCounter::get_count(Self, Int) -> Int
fn CallCounter::increment(Self, Int) -> Int
fn CallCounter::new() -> Self
fn CallCounter::reset(Self, Int) -> Unit
fn CallCounter::total(Self) -> Int
fn CallCounter::unique_functions(Self) -> Int

pub enum CompilationDecision {
  Interpret
  CompileAndExecute(CompilationMode)
  ExecuteCompiled
}
impl Show for CompilationDecision

pub enum CompilationMode {
  Interpret
  Baseline
  Optimized
}
impl Show for CompilationMode

pub(all) struct CompilationQueue {
  requests : Array[CompilationRequest]
  max_size : Int
}
fn CompilationQueue::clear(Self) -> Unit
fn CompilationQueue::contains(Self, Int) -> Bool
fn CompilationQueue::dequeue(Self) -> CompilationRequest?
fn CompilationQueue::enqueue(Self, CompilationRequest) -> Bool
fn CompilationQueue::is_empty(Self) -> Bool
fn CompilationQueue::length(Self) -> Int
fn CompilationQueue::new(Int) -> Self

pub(all) struct CompilationRequest {
  func_idx : Int
  mode : CompilationMode
  priority : Int
}
fn CompilationRequest::new(Int, CompilationMode) -> Self
fn CompilationRequest::with_priority(Int, CompilationMode, Int) -> Self

pub enum CompilationStatus {
  NotCompiled
  Compiling
  Compiled
  Failed(String)
}
impl Show for CompilationStatus

pub(all) struct CompilationStrategy {
  profiler : Profiler
  queue : CompilationQueue
  config : TieredConfig
  mut decisions_interpret : Int
  mut decisions_compile : Int
  mut decisions_compiled : Int
}
fn CompilationStrategy::decide(Self, Int) -> CompilationDecision
fn CompilationStrategy::is_compiled(Self, Int) -> Bool
fn CompilationStrategy::mark_compiled(Self, Int) -> Unit
fn CompilationStrategy::new(TieredConfig) -> Self
fn CompilationStrategy::next_to_compile(Self) -> CompilationRequest?
fn CompilationStrategy::schedule_compilation(Self, Int, CompilationMode) -> Bool
fn CompilationStrategy::stats(Self) -> (Int, Int, Int, Int, Int, Int)
impl Show for CompilationStrategy

pub(all) struct DebugContext {
  source_map : SourceMap
  breakpoints : BreakpointManager
  mut enabled : Bool
  mut step_mode : StepMode
  mut current_trace : StackTrace?
}
fn DebugContext::disable(Self) -> Unit
fn DebugContext::enable(Self) -> Unit
fn DebugContext::location_string(Self, Int, Int) -> String
fn DebugContext::new() -> Self
fn DebugContext::on_pause(Self, Int, Int) -> Unit
fn DebugContext::set_step_mode(Self, StepMode) -> Unit
fn DebugContext::should_pause(Self, Int, Int) -> Bool
impl Show for DebugContext

pub(all) struct FunctionEntry {
  func_idx : Int
  mut status : CompilationStatus
  mut compiled_code : @vcode.CompiledFunction?
  mut call_count : Int
}
fn FunctionEntry::is_compiled(Self) -> Bool
fn FunctionEntry::new(Int) -> Self

pub enum FunctionTemperature {
  Cold
  Warm
  Hot
}
impl Show for FunctionTemperature

pub(all) struct HotThreshold {
  warm_threshold : Int
  hot_threshold : Int
}
fn HotThreshold::aggressive() -> Self
fn HotThreshold::conservative() -> Self
fn HotThreshold::default() -> Self

pub(all) struct JITEngine {
  strategy : CompilationStrategy
  runtime : @vcode.JITRuntime
  functions : Map[Int, FunctionEntry]
  mut total_calls : Int
  mut jit_calls : Int
  mut interpreter_calls : Int
  mut compilation_failures : Int
}
fn JITEngine::default() -> Self
fn JITEngine::get_compiled(Self, Int) -> @vcode.CompiledFunction?
fn JITEngine::invalidate(Self, Int) -> Unit
fn JITEngine::is_compiled(Self, Int) -> Bool
fn JITEngine::mark_compiled(Self, Int, @vcode.CompiledFunction) -> Unit
fn JITEngine::mark_failed(Self, Int, String) -> Unit
fn JITEngine::new(TieredConfig) -> Self
fn JITEngine::on_call(Self, Int) -> Bool
fn JITEngine::stats(Self) -> (Int, Int, Int, Int, Int)
impl Show for JITEngine

pub(all) struct Profiler {
  counter : CallCounter
  threshold : HotThreshold
  hot_functions : @hashset.HashSet[Int]
  pending_compilation : @hashset.HashSet[Int]
  compiled_functions : @hashset.HashSet[Int]
}
fn Profiler::get_function_temperature(Self, Int) -> FunctionTemperature
fn Profiler::get_pending(Self) -> Array[Int]
fn Profiler::is_compiled(Self, Int) -> Bool
fn Profiler::mark_compiled(Self, Int) -> Unit
fn Profiler::new(HotThreshold) -> Self
fn Profiler::record_call(Self, Int) -> (Int, Bool)
fn Profiler::should_use_jit(Self, Int) -> Bool
fn Profiler::stats(Self) -> (Int, Int, Int, Int)
impl Show for Profiler

pub(all) struct SourceLocation {
  func_idx : Int
  offset : Int
  file : String?
  line : Int?
  column : Int?
}
fn SourceLocation::new(Int, Int) -> Self
fn SourceLocation::with_source(Int, Int, String, Int, Int) -> Self
impl Show for SourceLocation

pub(all) struct SourceMap {
  mappings : Map[Int, Map[Int, SourceLocation]]
  func_names : Map[Int, String]
}
fn SourceMap::add_func_name(Self, Int, String) -> Unit
fn SourceMap::add_mapping(Self, Int, Int, SourceLocation) -> Unit
fn SourceMap::find_nearest(Self, Int, Int) -> SourceLocation?
fn SourceMap::get_func_name(Self, Int) -> String
fn SourceMap::get_location(Self, Int, Int) -> SourceLocation?
fn SourceMap::mapping_count(Self) -> Int
fn SourceMap::new() -> Self

pub(all) struct StackFrame {
  index : Int
  func_idx : Int
  ip : Int
  func_name : String
  location : SourceLocation?
  local_count : Int
}
fn StackFrame::new(Int, Int, Int, String) -> Self
fn StackFrame::with_location(Int, Int, Int, String, SourceLocation) -> Self
impl Show for StackFrame

pub(all) struct StackTrace {
  frames : Array[StackFrame]
  error : String?
}
fn StackTrace::depth(Self) -> Int
fn StackTrace::new() -> Self
fn StackTrace::push_frame(Self, StackFrame) -> Unit
fn StackTrace::with_error(String) -> Self
impl Show for StackTrace

pub enum StepMode {
  Continue
  StepInto
  StepOver
  StepOut
}
impl Show for StepMode

pub(all) struct TieredConfig {
  baseline_threshold : Int
  optimize_threshold : Int
  synchronous : Bool
  max_concurrent : Int
}
fn TieredConfig::default() -> Self
fn TieredConfig::deferred() -> Self
fn TieredConfig::eager() -> Self

// Type aliases

// Traits

